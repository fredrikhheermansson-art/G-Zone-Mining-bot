-- ADVANCED MINING TURTLE COORDINATE-MINER v4.0 ENHANCED EDITION
-- Minecraft Modded Edition with GPS-optimized room mining + high-performance strip mining
-- ENHANCED: Memory optimization, 3x3 mining, ore detection, emergency recovery, inventory compression, log rotation, detailed reports
-- MODDED: Full support for modded Minecraft with auto-detection and custom ore priorities
-- BUGFIXED: All critical issues resolved

-- ===== CRITICAL UTILITIES (MUST BE FIRST) =====
-- Helper function to trim strings
string.trim = function(s)
    return s:match("^%s*(.-)%s*$")
end

-- Safe table element counting
local function countTableElements(t)
    local count = 0
    for _ in pairs(t) do count = count + 1 end
    return count
end

-- Safe table emptiness check
local function isEmpty(t)
    for _ in pairs(t) do
        return false
    end
    return true
end

-- Safe division with default
local function safeDiv(a, b, default)
    default = default or 0
    if not b or b == 0 then return default end
    return a / b
end

-- Safe file operations
local function safeFileRead(filename)
    if not fs.exists(filename) then return nil end
    local success, result = pcall(function()
        local file = fs.open(filename, "r")
        if not file then return nil end
        local content = file.readAll()
        file.close()
        return content
    end)
    return success and result or nil
end

local function safeFileWrite(filename, content)
    local success, err = pcall(function()
        local file = fs.open(filename, "w")
        if not file then error("Cannot open file") end
        file.write(content)
        file.close()
    end)
    return success, err
end

-- Helper function for table.contains
local function tableContains(table, element)
    for _, value in pairs(table) do
        if value == element then
            return true
        end
    end
    return false
end

-- ===== EARLY VARIABLE INITIALIZATION =====
local discovered_ores = {}
local custom_ore_priorities = {}
local mining_active = true
local emergency_stop = false
local last_log_rotation = os.clock()

-- ===== EARLY LOG FUNCTION (MUST BE BEFORE ANY USAGE) =====
-- Enhanced logging with rotation
local function log(message, level)
    level = level or "INFO"
    local timestamp = os.clock()
    local formatted_msg = "[" .. level .. "][" .. string.format("%.1f", timestamp) .. "s] " .. message
    print(formatted_msg)
    
    -- Write to log file with error protection
    local success, err = pcall(function()
        local file = fs.open("turtle_mining.log", "a")
        if file then
            file.writeLine(os.day() .. ":" .. textutils.formatTime(os.time()) .. " " .. formatted_msg)
            file.close()
        end
    end)
    
    -- Check for log rotation (only if CONFIG is available)
    if CONFIG and os.clock() - last_log_rotation > 300 then -- Check every 5 minutes
        rotateLogFile()
        last_log_rotation = os.clock()
    end
    
    if level == "ERROR" then
        sleep(0.1)
    end
end

-- NEW: Log rotation function (simplified early version)
local function rotateLogFile()
    if fs.exists("turtle_mining.log") then
        local size = fs.getSize("turtle_mining.log")
        local rotation_size = (CONFIG and CONFIG.logRotationSize) or 100000 -- Default 100KB
        
        if size > rotation_size then
            -- Create logs directory if it doesn't exist
            if not fs.exists("logs") then
                fs.makeDir("logs")
            end
            
            -- Archive old log
            local timestamp = os.day() .. "_" .. math.floor(os.time())
            local archiveName = "logs/mining_" .. timestamp .. ".log"
            
            if fs.exists(archiveName) then
                -- Add counter if file already exists
                local counter = 1
                while fs.exists("logs/mining_" .. timestamp .. "_" .. counter .. ".log") do
                    counter = counter + 1
                end
                archiveName = "logs/mining_" .. timestamp .. "_" .. counter .. ".log"
            end
            
            fs.move("turtle_mining.log", archiveName)
            log("Rotated log file (size: " .. size .. " bytes) to " .. archiveName)
        end
    end
end

-- ===== CONFIGURATION =====
local CONFIG = {
    torchSlot = 16,
    chestSlot = 15,
    protectedSlots = {15, 16},
    minFuel = 1000,
    torchSpacing = 8,
    emergencyKey = "q",
    autoSmelt = true,
    maxChunkDistance = 64,
    stateSaveInterval = 10,
    maxRetries = 15,
    gpsTimeout = 15,  -- Reduced for Ender Modems (faster response)
    compassAttempts = 3,  -- Reduced - Ender Modems are more reliable
    maxDetourAttempts = 5,
    enderModemMode = true,  -- NEW: Indicates Ender Modem usage
    enable3x3Mining = true, -- NEW: Enable 3x3 mining mode
    followOreVeins = true,  -- NEW: Follow valuable ore veins
    maxOreVeinDepth = 32,   -- NEW: Max recursion for ore veins
    logRotationSize = 100000, -- NEW: 100KB log rotation
    torchCleanupAge = 3600,  -- NEW: Clean torches older than 1 hour
    -- MODDED MINECRAFT SUPPORT
    auto_detect_modded_ores = true,
    modded_ore_file = "custom_ores.txt",
    discovered_ores_file = "discovered_ores.txt",
    modded_keywords = {
        -- Metaller från moddar
        "aluminum", "aluminium", "osmium", "titanium", "platinum", "iridium",
        "cobalt", "ardite", "mithril", "mythril", "adamantine", "vibranium",
        "certus", "fluix", "nether_quartz", "black_quartz", "yellorite",
        "draconium", "end_steel", "dark_steel", "electrical_steel",
        "nickel", "zinc", "uranium", "thorium", "magnesium",
        
        -- Gems från moddar  
        "peridot", "ruby", "sapphire", "topaz", "amethyst", "amber",
        "fluorite", "apatite", "cinnabar", "sphalerite", "galena",
        "certus", "charged_certus", "fluix",
        
        -- Speciella material
        "dilithium", "tritanium", "naquadah", "neutronium", "unobtainium",
        "astral", "starmetal", "moonstone", "sunstone", "vinteum",
        "thaumium", "void", "primordial", "infused"
    },
    valuableItems = {
        "ore", "gem", "ingot", "crystal", "diamond", "emerald", 
        "gold", "iron", "copper", "tin", "silver", "lead", "uranium",
        "redstone", "lapis", "coal", "quartz", "glowstone", "debris",
        "osmium", "platinum", "cobalt", "ardite", "draconium", "certus"
    },
    junkItems = {
        "cobblestone", "stone", "dirt", "gravel", "sand", "andesite",
        "granite", "diorite", "deepslate", "tuff", "calcite", "dripstone"
    },
    dangerousBlocks = {
        "lava", "water", "flowing_lava", "flowing_water", "magma"
    },
    -- Vanilla ore priorities
    orePriorities = {
        ["minecraft:ancient_debris"] = {priority = 10, name = "Ancient Debris"},
        ["minecraft:diamond_ore"] = {priority = 10, name = "Diamond"},
        ["minecraft:deepslate_diamond_ore"] = {priority = 10, name = "Diamond"},
        ["minecraft:emerald_ore"] = {priority = 9, name = "Emerald"},
        ["minecraft:deepslate_emerald_ore"] = {priority = 9, name = "Emerald"},
        ["minecraft:gold_ore"] = {priority = 7, name = "Gold"},
        ["minecraft:deepslate_gold_ore"] = {priority = 7, name = "Gold"},
        ["minecraft:redstone_ore"] = {priority = 6, name = "Redstone"},
        ["minecraft:deepslate_redstone_ore"] = {priority = 6, name = "Redstone"},
        ["minecraft:iron_ore"] = {priority = 5, name = "Iron"},
        ["minecraft:deepslate_iron_ore"] = {priority = 5, name = "Iron"},
        ["minecraft:lapis_ore"] = {priority = 4, name = "Lapis"},
        ["minecraft:deepslate_lapis_ore"] = {priority = 4, name = "Lapis"},
        ["minecraft:copper_ore"] = {priority = 3, name = "Copper"},
        ["minecraft:deepslate_copper_ore"] = {priority = 3, name = "Copper"},
        ["minecraft:coal_ore"] = {priority = 2, name = "Coal"},
        ["minecraft:deepslate_coal_ore"] = {priority = 2, name = "Coal"}
    }
}

-- ===== GLOBAL VARIABLES =====
local turtle_pos = {x = 0, y = 0, z = 0, facing = 0}
local start_pos = {x = 0, y = 0, z = 0}
local torch_grid = {}
local chest_positions = {}
local stats = {
    blocks_mined = 0,
    items_collected = 0,
    chests_placed = 0,
    fuel_consumed = 0,
    runtime = 0,
    valuable_found = 0,
    start_time = 0,
    moves_since_save = 0,
    coordinate_updates = 0,
    coordinate_failures = 0,
    chests_avoided = 0,
    torches_replaced = 0,
    alternative_routes_used = 0,
    -- NEW: Enhanced statistics
    ore_types_found = {},
    liquids_encountered = 0,
    bedrock_hits = 0,
    emergency_returns = 0,
    inventory_compressions = 0,
    ore_veins_followed = 0,
    blocks_3x3_mined = 0,
    -- MODDED: Additional stats
    modded_ores_discovered = 0,
    custom_ores_found = 0
}

-- GPS Caching optimized for Ender Modems
local gps_cache = {
    position = {x = 0, y = 0, z = 0},
    timestamp = 0,
    cache_duration = 1  -- Adaptive: shorter for room mining, longer for strip mining
}

-- Mining configuration globals
local mining_length = nil
local mining_tunnelWidth = nil
local mining_spacing = nil
local mining_numTunnels = nil  
local mining_depth = nil
local mining_direction = nil
local mining_type = nil

-- ===== MODDED MINECRAFT SUPPORT FUNCTIONS =====

-- Ladda anpassade malmprioritet
local function loadCustomOrePriorities()
    if fs.exists(CONFIG.modded_ore_file) then
        local content = safeFileRead(CONFIG.modded_ore_file)
        if not content then
            log("Failed to read custom ore file", "ERROR")
            return false
        end
        
        local loaded_count = 0
        for line in content:gmatch("[^\r\n]+") do
            -- Skippa kommentarer och tomma rader
            line = line:trim()
            if line ~= "" and not line:find("^#") then
                -- Format: "modname:orename,priority,display_name"
                local parts = {}
                for part in line:gmatch("[^,]+") do
                    table.insert(parts, part:trim())
                end
                
                if #parts >= 2 then
                    local ore_name = parts[1]
                    local priority = tonumber(parts[2]) or 5
                    local display_name = parts[3] or ore_name:gsub(".*:", ""):gsub("_", " ")
                    
                    custom_ore_priorities[ore_name] = {
                        priority = priority,
                        name = display_name
                    }
                    loaded_count = loaded_count + 1
                end
            end
        end
        log("Loaded " .. loaded_count .. " custom ore priorities")
        return true
    else
        -- Skapa exempel-fil
        return createExampleOreFile()
    end
end

-- Skapa exempel-fil för anpassade malmer
local function createExampleOreFile()
    local example_content = {
        "# Anpassade malmprioritet för moddat Minecraft",
        "# Format: modname:malmnamn,prioritet,visningsnamn",
        "# Prioritet 7+ aktiverar automatisk åderföljning",
        "# Prioritet 1-4: Vanliga, 5-6: Användbara, 7-8: Värdefulla, 9-10: Extremt värdefulla",
        "",
        "# Thermal Foundation/Series",
        "thermal:copper_ore,6,Copper",
        "thermal:tin_ore,5,Tin", 
        "thermal:silver_ore,7,Silver",
        "thermal:lead_ore,6,Lead",
        "thermal:nickel_ore,7,Nickel",
        "thermal:platinum_ore,9,Platinum",
        "",
        "# Mekanism",
        "mekanism:osmium_ore,8,Osmium",
        "mekanism:fluorite_ore,6,Fluorite",
        "mekanism:uranium_ore,8,Uranium",
        "",
        "# Applied Energistics",
        "appliedenergistics2:quartz_ore,7,Certus Quartz",
        "appliedenergistics2:charged_quartz_ore,8,Charged Certus",
        "",
        "# Tinkers Construct",
        "tconstruct:cobalt_ore,9,Cobalt",
        "tconstruct:ardite_ore,9,Ardite",
        "",
        "# Draconic Evolution",
        "draconicevolution:draconium_ore,10,Draconium",
        "",
        "# IndustrialCraft 2",
        "ic2:tin_ore,5,Tin",
        "ic2:copper_ore,6,Copper",
        "ic2:uranium_ore,8,Uranium",
        "",
        "# Immersive Engineering",
        "immersiveengineering:ore_aluminum,6,Aluminum",
        "immersiveengineering:ore_silver,7,Silver",
        "immersiveengineering:ore_lead,6,Lead",
        "immersiveengineering:ore_nickel,7,Nickel",
        "immersiveengineering:ore_uranium,8,Uranium"
    }
    
    local success, err = safeFileWrite(CONFIG.modded_ore_file, table.concat(example_content, "\n"))
    if success then
        log("Created example ore configuration file: " .. CONFIG.modded_ore_file)
        log("Edit this file to customize ore priorities for your modpack!")
        return true
    else
        log("Failed to create example ore file: " .. (err or "unknown error"), "ERROR")
        return false
    end
end

-- Spara upptäckta malmer
local function saveDiscoveredOre(ore_name, priority, display_name)
    local timestamp = os.day() .. ":" .. textutils.formatTime(os.time())
    local entry = ore_name .. "," .. priority .. "," .. display_name .. " # Found: " .. timestamp .. "\n"
    
    local success, err = pcall(function()
        local file = fs.open(CONFIG.discovered_ores_file, "a")
        if file then
            file.write(entry)
            file.close()
            stats.modded_ores_discovered = stats.modded_ores_discovered + 1
            return true
        end
        return false
    end)
    
    if not success then
        log("Failed to save discovered ore: " .. (err or "unknown error"), "WARN")
    end
end

-- Förbättrad malmanalys som stöder moddar
local function analyzeModdedOre(direction)
    local inspectFunc
    if direction == "forward" then
        inspectFunc = turtle.inspect
    elseif direction == "up" then
        inspectFunc = turtle.inspectUp
    elseif direction == "down" then
        inspectFunc = turtle.inspectDown
    else
        return nil
    end
    
    local success, data = inspectFunc()
    if not success or not data.name then
        return nil
    end
    
    local block_name = data.name
    local lower_name = block_name:lower()
    
    -- 1. Kolla anpassade prioritet först
    if custom_ore_priorities[block_name] then
        local ore_info = custom_ore_priorities[block_name]
        log("Found custom ore: " .. ore_info.name .. " (priority " .. ore_info.priority .. ")")
        stats.ore_types_found[ore_info.name] = (stats.ore_types_found[ore_info.name] or 0) + 1
        stats.custom_ores_found = stats.custom_ores_found + 1
        return {
            name = block_name,
            priority = ore_info.priority,
            display_name = ore_info.name,
            direction = direction
        }
    end
    
    -- 2. Kolla vanilla prioritet
    if CONFIG.orePriorities[block_name] then
        local ore_info = CONFIG.orePriorities[block_name]
        log("Found vanilla ore: " .. ore_info.name .. " (priority " .. ore_info.priority .. ")")
        stats.ore_types_found[ore_info.name] = (stats.ore_types_found[ore_info.name] or 0) + 1
        return {
            name = block_name,
            priority = ore_info.priority,
            display_name = ore_info.name,
            direction = direction
        }
    end
    
    -- 3. Auto-detect nya malmer
    if CONFIG.auto_detect_modded_ores then
        -- Kolla om det innehåller ore-nyckelord
        local is_ore = lower_name:find("ore") or 
                      lower_name:find("gem") or
                      lower_name:find("crystal")
        
        if is_ore then
            -- Kolla mot kända värdefulla material
            local priority = 5  -- Standard prioritet
            local display_name = block_name:gsub(".*:", ""):gsub("_", " "):gsub("ore", ""):trim()
            if display_name == "" then
                display_name = block_name:gsub(".*:", "")
            end
            
            -- Högre prioritet för kända värdefulla material
            for _, valuable in ipairs(CONFIG.modded_keywords) do
                if lower_name:find(valuable) then
                    if valuable == "draconium" or valuable == "vibranium" or valuable == "unobtainium" or valuable == "neutronium" then
                        priority = 10
                        display_name = valuable:gsub("^%l", string.upper)
                    elseif valuable == "platinum" or valuable == "iridium" or valuable == "cobalt" or valuable == "ardite" then
                        priority = 9
                        display_name = valuable:gsub("^%l", string.upper)
                    elseif valuable == "osmium" or valuable == "silver" or valuable == "certus" or valuable == "uranium" then
                        priority = 8
                        display_name = valuable:gsub("^%l", string.upper)
                    elseif valuable == "nickel" or valuable == "titanium" or valuable == "thorium" then
                        priority = 7
                        display_name = valuable:gsub("^%l", string.upper)
                    else
                        priority = 6
                        display_name = valuable:gsub("^%l", string.upper)
                    end
                    break
                end
            end
            
            -- Spara upptäckt om det är nytt
            if not discovered_ores[block_name] then
                discovered_ores[block_name] = {
                    priority = priority,
                    name = display_name,
                    first_found = os.clock()
                }
                saveDiscoveredOre(block_name, priority, display_name)
                log("NEW MODDED ORE DISCOVERED: " .. display_name .. " (" .. block_name .. ") - priority " .. priority)
                
                if priority >= 7 then
                    log("HIGH VALUE ORE! Will follow ore veins for " .. display_name)
                end
            end
            
            stats.ore_types_found[display_name] = (stats.ore_types_found[display_name] or 0) + 1
            
            return {
                name = block_name,
                priority = priority,
                display_name = display_name,
                direction = direction
            }
        end
    end
    
    return nil
end

-- Initialisering för moddat stöd
local function initializeModdedSupport()
    log("=== INITIALIZING MODDED MINECRAFT SUPPORT ===")
    log("Auto-detection enabled: " .. tostring(CONFIG.auto_detect_modded_ores))
    log("Known modded keywords: " .. #CONFIG.modded_keywords)
    
    -- Ladda anpassade malmprioriteter
    if not loadCustomOrePriorities() then
        log("Failed to load custom ore priorities", "WARN")
    end
    
    -- Ladda tidigare upptäckta malmer
    if fs.exists(CONFIG.discovered_ores_file) then
        local content = safeFileRead(CONFIG.discovered_ores_file)
        if content then
            local count = 0
            for line in content:gmatch("[^\r\n]+") do
                if not line:find("#") and line:trim() ~= "" then
                    local parts = {}
                    for part in line:gmatch("[^,]+") do
                        table.insert(parts, part:trim())
                    end
                    
                    if #parts >= 3 then
                        discovered_ores[parts[1]] = {
                            priority = tonumber(parts[2]) or 5,
                            name = parts[3]:gsub(" #.*", "")
                        }
                        count = count + 1
                    end
                end
            end
            if count > 0 then
                log("Loaded " .. count .. " previously discovered ores")
            end
        end
    end
    
    log("Modded Minecraft support initialized!")
    log("Custom ore priorities: " .. countTableElements(custom_ore_priorities))
    log("Previously discovered: " .. countTableElements(discovered_ores))
    log("Edit '" .. CONFIG.modded_ore_file .. "' to customize ore priorities")
    return true
end

-- ===== UTILITY FUNCTIONS =====
-- NEW: Memory optimization - cleanup old torch positions
local function cleanupOldTorchPositions()
    local current_time = os.clock()
    local cleanup_count = 0
    
    for y, xz_table in pairs(torch_grid) do
        for x, z_table in pairs(xz_table) do
            for z, torch_data in pairs(z_table) do
                -- Remove torches older than configured age
                if current_time - torch_data.timestamp > CONFIG.torchCleanupAge then
                    torch_grid[y][x][z] = nil
                    cleanup_count = cleanup_count + 1
                end
            end
            -- Clean up empty tables
            if isEmpty(torch_grid[y][x]) then
                torch_grid[y][x] = nil
            end
        end
        -- Clean up empty tables
        if isEmpty(torch_grid[y]) then
            torch_grid[y] = nil
        end
    end
    
    if cleanup_count > 0 then
        log("Cleaned up " .. cleanup_count .. " old torch positions (memory optimization)")
    end
end

-- ===== STATE MANAGEMENT =====
local function saveState()
    mining_length = mining_length or 0
    mining_tunnelWidth = mining_tunnelWidth or 0
    mining_spacing = mining_spacing or 0
    mining_numTunnels = mining_numTunnels or 0
    mining_depth = mining_depth or 0
    mining_direction = mining_direction or "right"
    mining_type = mining_type or "parallel"
    
    local state = {
        position = turtle_pos,
        start = start_pos,
        stats = stats,
        config = CONFIG,
        torch_grid = torch_grid,
        chest_positions = chest_positions,
        discovered_ores = discovered_ores,
        custom_ore_priorities = custom_ore_priorities,
        mining_config = {
            length = mining_length,
            tunnelWidth = mining_tunnelWidth,
            spacing = mining_spacing,
            numTunnels = mining_numTunnels,
            depth = mining_depth,
            direction = mining_direction,
            type = mining_type
        }
    }
    
    local success, err = pcall(function()
        local file = fs.open("miner_complete_state.json", "w")
        file.write(textutils.serialiseJSON(state))
        file.close()
    end)
    
    if success then
        stats.moves_since_save = 0
    else
        log("Failed to save state: " .. (err or "unknown error"), "WARN")
    end
end

local function loadState()
    if fs.exists("miner_complete_state.json") then
        local content = safeFileRead("miner_complete_state.json")
        if content then
            local state = textutils.unserialiseJSON(content)
            if state then
                turtle_pos = state.position or turtle_pos
                start_pos = state.start or start_pos
                
                -- Merge stats carefully to ensure all fields exist
                local loaded_stats = state.stats or {}
                for key, default_value in pairs(stats) do
                    if loaded_stats[key] ~= nil then
                        stats[key] = loaded_stats[key]
                    end
                end
                
                -- Ensure all stats fields exist
                stats.ore_types_found = stats.ore_types_found or {}
                stats.liquids_encountered = stats.liquids_encountered or 0
                stats.bedrock_hits = stats.bedrock_hits or 0
                stats.emergency_returns = stats.emergency_returns or 0
                stats.inventory_compressions = stats.inventory_compressions or 0
                stats.ore_veins_followed = stats.ore_veins_followed or 0
                stats.blocks_3x3_mined = stats.blocks_3x3_mined or 0
                stats.modded_ores_discovered = stats.modded_ores_discovered or 0
                stats.custom_ores_found = stats.custom_ores_found or 0
                
                torch_grid = state.torch_grid or {}
                chest_positions = state.chest_positions or {}
                discovered_ores = state.discovered_ores or {}
                custom_ore_priorities = state.custom_ore_priorities or {}
                
                if state.mining_config then
                    mining_length = state.mining_config.length
                    mining_tunnelWidth = state.mining_config.tunnelWidth
                    mining_spacing = state.mining_config.spacing
                    mining_numTunnels = state.mining_config.numTunnels
                    mining_depth = state.mining_config.depth
                    mining_direction = state.mining_config.direction
                    mining_type = state.mining_config.type
                    log("Loaded mining configuration")
                end
                
                local chest_count = 0
                for y, xz in pairs(chest_positions) do
                    for x, z_table in pairs(xz) do
                        for z, _ in pairs(z_table) do
                            chest_count = chest_count + 1
                        end
                    end
                end
                if chest_count > 0 then
                    log("Loaded " .. chest_count .. " chest positions")
                end
                
                log("Loaded saved state with " .. countTableElements(discovered_ores) .. " discovered ores")
                return true
            end
        end
    end
    return false
end

-- NEW: Save emergency position for recovery
local function saveEmergencyPosition()
    local emergency_pos = {
        x = turtle_pos.x,
        y = turtle_pos.y,
        z = turtle_pos.z,
        facing = turtle_pos.facing,
        timestamp = os.clock(),
        fuel_level = turtle.getFuelLevel()
    }
    
    local success, err = safeFileWrite("emergency_position.json", textutils.serialiseJSON(emergency_pos))
    if success then
        log("Saved emergency position for recovery")
    else
        log("Failed to save emergency position: " .. (err or "unknown error"), "ERROR")
    end
end

-- ===== COORDINATE SYSTEM =====
local function updatePosition(force_gps)
    -- Adaptive cache duration based on mining type
    local cache_duration = mining_type == "room" and 0.5 or 2
    
    if not force_gps then
        local current_time = os.clock()
        if current_time - gps_cache.timestamp < cache_duration then
            turtle_pos.x = gps_cache.position.x
            turtle_pos.y = gps_cache.position.y  
            turtle_pos.z = gps_cache.position.z
            return true, "GPS_CACHED"
        end
    end
    
    -- Ender Modems: Reliable GPS at all depths, fewer retries needed
    local max_attempts = 3  -- Reduced from 5 - Ender Modems are more reliable
    for attempt = 1, max_attempts do
        if attempt > 1 then
            log("GPS attempt " .. attempt .. "/" .. max_attempts .. " (Ender Modem)")
        end
        
        local x, y, z = gps.locate(CONFIG.gpsTimeout)
        if x and y and z then
            turtle_pos.x = math.floor(x + 0.5)
            turtle_pos.y = math.floor(y + 0.5)
            turtle_pos.z = math.floor(z + 0.5)
            
            -- Update cache
            gps_cache.position = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z}
            gps_cache.timestamp = os.clock()
            
            stats.coordinate_updates = stats.coordinate_updates + 1
            return true, "GPS_ENDER"
        else
            stats.coordinate_failures = stats.coordinate_failures + 1
            if attempt < max_attempts then
                log("GPS failed, attempt " .. attempt .. "/" .. max_attempts .. " - waiting 2 seconds...", "WARN")
                sleep(2)  -- Reduced wait time for Ender Modems
            end
        end
    end
    
    -- With Ender Modems, GPS failure is more serious
    log("CRITICAL: GPS failed after " .. max_attempts .. " attempts with Ender Modem!", "ERROR") 
    log("Check: 1) Ender Modem on turtle, 2) GPS towers have Ender Modems, 3) GPS host running", "ERROR")
    return false, "GPS_ENDER_FAILURE"
end

local function detectFacing()
    log("Determining direction via coordinate measurement...")
    
    local success, method = updatePosition(true)
    if not success then
        log("Cannot determine direction without coordinates", "ERROR")
        return false
    end
    
    local start_x, start_z = turtle_pos.x, turtle_pos.z
    
    if turtle.forward() then
        -- Ender Modems: Short wait for GPS update
        log("Waiting for GPS to update position after movement...")
        sleep(1)  -- Reduced wait time for Ender Modems
        
        local success2, method2 = updatePosition(true)
        if success2 then
            local dx = turtle_pos.x - start_x
            local dz = turtle_pos.z - start_z
            
            if dx > 0 then
                turtle_pos.facing = 1
            elseif dx < 0 then
                turtle_pos.facing = 3
            elseif dz > 0 then
                turtle_pos.facing = 2
            elseif dz < 0 then
                turtle_pos.facing = 0
            else
                log("No clear directional change detected - using fallback", "WARN")
                turtle_pos.facing = 0
            end
            
            turtle.turnRight()
            turtle.turnRight()
            if turtle.forward() then
                sleep(0.5)  -- Shorter wait for Ender Modems
                updatePosition(false)  -- Use cache
            else
                log("Could not return to start position during direction detection", "WARN")
            end
            turtle.turnRight()
            turtle.turnRight()
            
            log("Direction: " .. turtle_pos.facing .. " (0=N,1=E,2=S,3=W) via " .. method2)
            return true
        else
            log("GPS failed after movement - cannot determine direction", "ERROR")
            turtle.turnRight()
            turtle.turnRight()
            turtle.forward()
            turtle.turnRight()
            turtle.turnRight()
            return false
        end
    else
        log("Cannot move forward to detect direction", "ERROR")
        return false
    end
end

local function initializeCoordinates()
    log("=== INITIALIZING ENDER MODEM GPS SYSTEM ===")
    log("Mining type: " .. (mining_type or "unknown"))
    log("Ender Modem: Unlimited range GPS for both room and strip mining")
    
    log("Testing Ender Modem GPS system...")
    local success, method = updatePosition(true)
    
    if success then
        log("Ender Modem GPS working: " .. method)
        log("Position: " .. turtle_pos.x .. ", " .. turtle_pos.y .. ", " .. turtle_pos.z)
    else
        log("Ender Modem GPS system not responding!", "ERROR")
        log("CRITICAL: Both room and strip mining work better with Ender Modem GPS!", "ERROR")
        log("Please ensure:", "ERROR")
        log("1. Turtle has Ender Modem equipped", "ERROR") 
        log("2. GPS towers have Ender Modems (not wireless modems)", "ERROR")
        log("3. GPS host programs running: 'gps host x y z'", "ERROR")
        log("4. At least 4 GPS towers at different positions", "ERROR")
        
        sleep(1)
        
        -- For strip mining, offer manual coordinates as fallback
        if mining_type ~= "room" then
            log("Strip mining can continue with manual coordinates if needed", "WARN")
            sleep(0.5)
            print("Enter coordinates manually for strip mining? (y/n): ")
            local input = read():lower()
            if input == "y" or input == "yes" then
                print("Enter X: ")
                turtle_pos.x = tonumber(read()) or 0
                print("Enter Y: ")
                turtle_pos.y = tonumber(read()) or 0  
                print("Enter Z: ")
                turtle_pos.z = tonumber(read()) or 0
                log("Manual coords: " .. turtle_pos.x .. ", " .. turtle_pos.y .. ", " .. turtle_pos.z)
                success = true
                method = "manual"
            else
                log("Using fallback coords (0,0,0) - relative navigation", "WARN")
                turtle_pos = {x = 0, y = 0, z = 0, facing = 0}
                success = true
                method = "fallback"
            end
        else
            -- Room mining requires GPS
            local retry_count = 0
            local max_retries = 3
            
            while retry_count < max_retries do
                print("")
                print("Try again? (" .. (retry_count + 1) .. "/" .. max_retries .. ") y/n: ")
                local input = read():lower()
                if input == "y" or input == "yes" then
                    retry_count = retry_count + 1
                    log("Retrying Ender Modem GPS...")
                    success, method = updatePosition(true)
                    if success then
                        log("Ender Modem GPS now working: " .. method)
                        log("Position: " .. turtle_pos.x .. ", " .. turtle_pos.y .. ", " .. turtle_pos.z)
                        break
                    else
                        log("Ender Modem GPS still failed (attempt " .. retry_count .. ")")
                    end
                else
                    log("Room mining cancelled - GPS required")
                    return false
                end
            end
            
            if not success then
                log("Ender Modem GPS failed after " .. max_retries .. " attempts - cannot do room mining", "ERROR")
                return false
            end
        end
    end
    
    if not detectFacing() then
        log("Could not determine direction - using North (0)", "WARN")
        turtle_pos.facing = 0
    end
    
    -- Initialize GPS cache for Ender Modems
    if method == "GPS_ENDER" or method == "GPS" then
        gps_cache.position = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z}
        gps_cache.timestamp = os.clock()
        log("Ender Modem GPS cache initialized")
    end
    
    log("Coordinate system ready - Method: " .. (method or "unknown"))
    return true
end

-- ===== TORCH AND CHEST POSITION TRACKING =====
local function isTorchAtPosition(x, y, z)
    return torch_grid[y] and torch_grid[y][x] and torch_grid[y][x][z]
end

local function addTorchPosition(x, y, z, placement_type)
    if not torch_grid[y] then torch_grid[y] = {} end
    if not torch_grid[y][x] then torch_grid[y][x] = {} end
    torch_grid[y][x][z] = {type = placement_type, timestamp = os.clock()}
end

local function isChestAtPosition(x, y, z)
    return chest_positions[y] and chest_positions[y][x] and chest_positions[y][x][z]
end

local function addChestPosition(x, y, z)
    if not chest_positions[y] then chest_positions[y] = {} end
    if not chest_positions[y][x] then chest_positions[y][x] = {} end
    chest_positions[y][x][z] = true
    log("Recorded chest at " .. x .. "," .. y .. "," .. z)
end

local function shouldAvoidDigging(x, y, z, direction)
    -- Only avoid chests, allow digging torches
    if isChestAtPosition(x, y, z) then
        log("Avoiding chest at " .. x .. "," .. y .. "," .. z .. " (" .. direction .. ")")
        stats.chests_avoided = stats.chests_avoided + 1
        return true
    end
    
    -- Allow digging torches - they're cheap to replace
    if isTorchAtPosition(x, y, z) then
        log("Digging through torch at " .. x .. "," .. y .. "," .. z .. " (" .. direction .. ") - will replace")
        stats.torches_replaced = stats.torches_replaced + 1
        return false  -- Allow digging torches
    end
    
    return false
end

-- ===== MOVEMENT & NAVIGATION =====
local function turnRight()
    turtle.turnRight()
    turtle_pos.facing = (turtle_pos.facing + 1) % 4
end

local function turnLeft()
    turtle.turnLeft()
    turtle_pos.facing = (turtle_pos.facing - 1) % 4
end

local function isLiquid(block_name)
    if not block_name then return false end
    local name = block_name:lower()
    for _, dangerous in ipairs(CONFIG.dangerousBlocks) do
        if name:find(dangerous) then
            stats.liquids_encountered = stats.liquids_encountered + 1
            return true
        end
    end
    return false
end

-- Use the modded ore analysis function
local function analyzeOre(direction)
    return analyzeModdedOre(direction)
end

-- NEW: Follow ore veins for maximum yield with position tracking to prevent infinite loops
local function followOreVein(ore_name, depth, visited)
    depth = depth or 0
    visited = visited or {}
    
    if depth > CONFIG.maxOreVeinDepth then 
        log("Reached maximum ore vein depth (" .. depth .. ")")
        return 
    end
    
    local pos_key = turtle_pos.x .. "," .. turtle_pos.y .. "," .. turtle_pos.z
    if visited[pos_key] then
        return  -- Already visited this position
    end
    visited[pos_key] = true
    
    local original_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z, facing = turtle_pos.facing}
    local directions = {"forward", "up", "down", "left", "right", "back"}
    local ore_count = 0
    
    for _, dir in ipairs(directions) do
        local check_success, check_data
        
        if dir == "forward" then
            check_success, check_data = turtle.inspect()
        elseif dir == "up" then
            check_success, check_data = turtle.inspectUp()
        elseif dir == "down" then
            check_success, check_data = turtle.inspectDown()
        elseif dir == "left" then
            turnLeft()
            check_success, check_data = turtle.inspect()
        elseif dir == "right" then
            turnRight()
            check_success, check_data = turtle.inspect()
        elseif dir == "back" then
            turnRight()
            turnRight()
            check_success, check_data = turtle.inspect()
        end
        
        if check_success and check_data.name == ore_name then
            ore_count = ore_count + 1
            
            -- Mine and follow the vein
            if dir == "forward" then
                if protectedDig("forward") and safeMove("forward") then
                    followOreVein(ore_name, depth + 1, visited)
                    -- Return to original position
                    turnRight()
                    turnRight()
                    safeMove("forward")
                    turnRight()
                    turnRight()
                end
            elseif dir == "up" then
                if protectedDig("up") and safeMove("up") then
                    followOreVein(ore_name, depth + 1, visited)
                    safeMove("down")
                end
            elseif dir == "down" then
                if protectedDig("down") and safeMove("down") then
                    followOreVein(ore_name, depth + 1, visited)
                    safeMove("up")
                end
            elseif dir == "left" then
                if protectedDig("forward") and safeMove("forward") then
                    followOreVein(ore_name, depth + 1, visited)
                    turnRight()
                    turnRight()
                    safeMove("forward")
                    turnRight()
                end
            elseif dir == "right" then
                if protectedDig("forward") and safeMove("forward") then
                    followOreVein(ore_name, depth + 1, visited)
                    turnRight()
                    turnRight()
                    safeMove("forward")
                    turnLeft()
                end
            elseif dir == "back" then
                if protectedDig("forward") and safeMove("forward") then
                    followOreVein(ore_name, depth + 1, visited)
                    turnRight()
                    turnRight()
                    safeMove("forward")
                end
            end
        end
        
        -- Return to correct facing
        while turtle_pos.facing ~= original_pos.facing do
            turnRight()
        end
    end
    
    if ore_count > 0 and depth == 0 then
        stats.ore_veins_followed = stats.ore_veins_followed + 1
        log("Completed following ore vein, found " .. ore_count .. " additional blocks")
    end
end

local function protectedDig(direction)
    local target_x, target_y, target_z = turtle_pos.x, turtle_pos.y, turtle_pos.z
    local digFunc, inspectFunc
    
    if direction == "forward" then
        if turtle_pos.facing == 0 then target_z = target_z - 1
        elseif turtle_pos.facing == 1 then target_x = target_x + 1
        elseif turtle_pos.facing == 2 then target_z = target_z + 1
        elseif turtle_pos.facing == 3 then target_x = target_x - 1
        end
        digFunc = turtle.dig
        inspectFunc = turtle.inspect
    elseif direction == "up" then
        target_y = target_y + 1
        digFunc = turtle.digUp
        inspectFunc = turtle.inspectUp
    elseif direction == "down" then
        target_y = target_y - 1
        digFunc = turtle.digDown
        inspectFunc = turtle.inspectDown
    else
        return false
    end
    
    -- Check if we should avoid digging this position
    if shouldAvoidDigging(target_x, target_y, target_z, direction) then
        return false  -- Do not dig protected blocks
    end
    
    -- Check for valuable ores before digging
    local ore_info = analyzeOre(direction)
    
    -- Check for dangerous liquids
    local success, data = inspectFunc()
    if success and isLiquid(data.name) then
        log("DANGER: Liquid detected (" .. data.name .. ") - not digging!", "ERROR")
        return false
    end
    
    -- Check for bedrock
    if success and data.name and data.name:lower():find("bedrock") then
        log("Hit bedrock at " .. target_x .. "," .. target_y .. "," .. target_z)
        stats.bedrock_hits = stats.bedrock_hits + 1
        return false
    end
    
    -- Safe to dig
    local result = digFunc()
    if result then
        stats.blocks_mined = stats.blocks_mined + 1
        
        -- Follow ore vein if valuable enough
        if ore_info and ore_info.priority >= 7 and CONFIG.followOreVeins then
            log("Following " .. ore_info.display_name .. " vein...")
            followOreVein(ore_info.name)
        end
    end
    return result
end

-- NEW: 3x3 mining for efficiency
local function mine3x3Forward()
    if not CONFIG.enable3x3Mining then
        return protectedDig("forward")
    end
    
    log("Executing 3x3 mining pattern")
    local blocks_mined = 0
    local original_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z, facing = turtle_pos.facing}
    
    -- Mine center forward
    if protectedDig("forward") then
        blocks_mined = blocks_mined + 1
    end
    
    -- Mine above and below center
    if protectedDig("up") then
        blocks_mined = blocks_mined + 1
    end
    if protectedDig("down") then
        blocks_mined = blocks_mined + 1
    end
    
    -- Move forward to mine the 3x3 area
    if safeMove("forward") then
        -- Mine current column (already did forward)
        if protectedDig("up") then
            blocks_mined = blocks_mined + 1
        end
        if protectedDig("down") then
            blocks_mined = blocks_mined + 1
        end
        
        -- Mine left column
        turnLeft()
        if protectedDig("forward") then
            blocks_mined = blocks_mined + 1
            if safeMove("forward") then
                if protectedDig("up") then
                    blocks_mined = blocks_mined + 1
                end
                if protectedDig("down") then
                    blocks_mined = blocks_mined + 1
                end
                -- Return to center
                turnRight()
                turnRight()
                safeMove("forward")
                turnLeft()
            end
        end
        
        -- Mine right column
        turnRight()
        if protectedDig("forward") then
            blocks_mined = blocks_mined + 1
            if safeMove("forward") then
                if protectedDig("up") then
                    blocks_mined = blocks_mined + 1
                end
                if protectedDig("down") then
                    blocks_mined = blocks_mined + 1
                end
                -- Return to center
                turnRight()
                turnRight()
                safeMove("forward")
                turnRight()
            end
        end
        
        -- Already in correct position and facing
    end
    
    stats.blocks_3x3_mined = stats.blocks_3x3_mined + blocks_mined
    log("3x3 mining completed, mined " .. blocks_mined .. " blocks")
    return blocks_mined > 0
end

local function safeMove(direction)
    local moveFunc, detectFunc, attackFunc
    
    if direction == "forward" then
        moveFunc = turtle.forward
        detectFunc = turtle.detect
        attackFunc = turtle.attack
    elseif direction == "up" then
        moveFunc = turtle.up
        detectFunc = turtle.detectUp
        attackFunc = turtle.attackUp
    elseif direction == "down" then
        moveFunc = turtle.down
        detectFunc = turtle.detectDown
        attackFunc = turtle.attackDown
    elseif direction == "back" then
        moveFunc = turtle.back
        detectFunc = function() 
            turnRight()
            turnRight()
            local result = turtle.detect()
            turnRight()
            turnRight()
            return result
        end
        attackFunc = function()
            turnRight()
            turnRight()
            local result = turtle.attack()
            turnRight()
            turnRight()
            return result
        end
    end
    
    for attempt = 1, CONFIG.maxRetries do
        if moveFunc() then
            -- Ender Modems: Update GPS more frequently for precise deep mining
            local update_gps = (stats.moves_since_save % 3 == 0)  -- Every 3 moves instead of 5-10
            
            if update_gps then
                local success, method = updatePosition(false)  -- Use cache when possible
                if not success then
                    if method == "GPS_ENDER_FAILURE" then
                        log("CRITICAL: Ender Modem GPS failure during mining!", "ERROR")
                        return false
                    end
                    log("GPS cache miss - continuing with dead reckoning", "WARN")
                end
            else
                -- Dead reckoning update (backup for Ender Modems)
                if direction == "forward" then
                    if turtle_pos.facing == 0 then 
                        turtle_pos.z = turtle_pos.z - 1
                    elseif turtle_pos.facing == 1 then 
                        turtle_pos.x = turtle_pos.x + 1
                    elseif turtle_pos.facing == 2 then 
                        turtle_pos.z = turtle_pos.z + 1
                    elseif turtle_pos.facing == 3 then 
                        turtle_pos.x = turtle_pos.x - 1
                    end
                elseif direction == "up" then
                    turtle_pos.y = turtle_pos.y + 1
                elseif direction == "down" then
                    turtle_pos.y = turtle_pos.y - 1
                elseif direction == "back" then
                    if turtle_pos.facing == 0 then 
                        turtle_pos.z = turtle_pos.z + 1
                    elseif turtle_pos.facing == 1 then 
                        turtle_pos.x = turtle_pos.x - 1
                    elseif turtle_pos.facing == 2 then 
                        turtle_pos.z = turtle_pos.z - 1
                    elseif turtle_pos.facing == 3 then 
                        turtle_pos.x = turtle_pos.x + 1
                    end
                end
            end
            
            stats.moves_since_save = stats.moves_since_save + 1
            if stats.moves_since_save >= CONFIG.stateSaveInterval then
                saveState()
            end
            
            -- Clean up old torch positions periodically
            if stats.moves_since_save % 100 == 0 then
                cleanupOldTorchPositions()
            end
            
            return true
        end
        
        if detectFunc() then
            if direction ~= "back" and not protectedDig(direction) then
                log("Cannot dig " .. direction .. " - protected block or danger", "WARN")
                return false
            end
        elseif attackFunc() then
            sleep(0.5)
        else
            sleep(0.1)
        end
    end
    
    log("Failed to move " .. direction .. " after " .. CONFIG.maxRetries .. " attempts", "ERROR")
    return false
end

local function smartMove(direction, allow_vertical_detour)
    allow_vertical_detour = allow_vertical_detour or false
    
    if safeMove(direction) then
        return true
    end
    
    if direction == "forward" then
        log("Forward blocked - trying alternative routes", "INFO")
        stats.alternative_routes_used = stats.alternative_routes_used + 1
        
        local original_facing = turtle_pos.facing
        
        -- Strategy 1: Right detour
        turnRight()
        if safeMove("forward") then
            turnLeft()
            if safeMove("forward") then
                turnLeft()
                if safeMove("forward") then
                    turnRight()
                    log("Successfully navigated around obstacle (right detour)")
                    return true
                else
                    turnRight()
                    log("Partial right detour successful")
                    return true
                end
            else
                turnRight()
                safeMove("forward")
                turnLeft()
            end
        else
            turnLeft()
        end
        
        -- Strategy 2: Left detour
        turnLeft()
        if safeMove("forward") then
            turnRight()
            if safeMove("forward") then
                turnRight()
                if safeMove("forward") then
                    turnLeft()
                    log("Successfully navigated around obstacle (left detour)")
                    return true
                else
                    turnLeft()
                    log("Partial left detour successful")
                    return true
                end
            else
                turnLeft()
                safeMove("forward")
                turnRight()
            end
        else
            turnRight()
        end
        
        -- Strategy 3: Vertical detour (if allowed)
        if allow_vertical_detour then
            log("Trying vertical detour", "INFO")
            if safeMove("up") then
                if safeMove("forward") then
                    if safeMove("down") then
                        log("Successfully navigated over obstacle")
                        return true
                    else
                        log("Vertical detour: stayed at higher level")
                        return true
                    end
                else
                    safeMove("down")
                end
            end
            
            -- Try going down and around
            if safeMove("down") then
                if safeMove("forward") then
                    if safeMove("up") then
                        log("Successfully navigated under obstacle")
                        return true
                    else
                        log("Vertical detour: stayed at lower level")
                        return true
                    end
                else
                    safeMove("up")
                end
            end
        end
        
        log("All alternative routes failed", "WARN")
        return false
    end
    
    return false
end

local function navigateToCoordinate(target_x, target_y, target_z, max_attempts)
    max_attempts = max_attempts or 80  -- Reduced - Ender Modems are more reliable
    local attempts = 0
    local last_distance = math.huge
    local stuck_attempts = 0
    
    log("Navigating to: " .. target_x .. ", " .. target_y .. ", " .. target_z)
    
    while attempts < max_attempts do
        attempts = attempts + 1
        
        -- Ender Modems: Check GPS more frequently for precision
        if attempts == 1 or attempts % 3 == 0 then  -- Every 3 attempts instead of 5
            local success, method = updatePosition(false)  -- Use cache when possible
            if not success then
                if method == "GPS_ENDER_FAILURE" then
                    log("CRITICAL: Ender Modem GPS failure during navigation!", "ERROR")
                    return false
                end
                log("GPS timeout during navigation attempt " .. attempts .. " - using last known position", "WARN")
            end
        end
        
        local dx = target_x - turtle_pos.x
        local dy = target_y - turtle_pos.y
        local dz = target_z - turtle_pos.z
        local current_distance = math.abs(dx) + math.abs(dy) + math.abs(dz)
        
        -- Check if we've arrived (Ender Modems allow for exact positioning)
        if current_distance == 0 then
            log("Reached exact target coordinates!")
            return true
        elseif current_distance <= 1 then
            log("Reached target coordinates (within 1 block)!")
            return true
        end
        
        -- Check if we're stuck
        if current_distance >= last_distance then
            stuck_attempts = stuck_attempts + 1
            if stuck_attempts > 3 then  -- Reduced threshold for Ender Modems
                log("Navigation appears stuck - trying alternative approach", "WARN")
                for i = 1, 4 do
                    if smartMove("forward", true) then
                        break
                    end
                    turnRight()
                end
                stuck_attempts = 0
            end
        else
            stuck_attempts = 0
        end
        last_distance = current_distance
        
        -- Y-axis first (most important for deep mining)
        if math.abs(dy) > 0 then
            if dy > 0 then
                if not smartMove("up", false) then
                    log("Blocked upward - trying horizontal movement", "WARN")
                    -- Try horizontal movement when vertical is blocked
                    if math.abs(dx) > 0 then
                        local target_facing = (dx > 0) and 1 or 3
                        while turtle_pos.facing ~= target_facing do
                            turnRight()
                        end
                        if smartMove("forward", true) then
                            -- Try vertical again after horizontal movement
                            smartMove("up", false)
                        end
                    end
                end
            else
                if not smartMove("down", false) then
                    log("Blocked downward - checking for bedrock", "WARN")
                    if turtle_pos.y <= -64 then
                        log("At bedrock level - cannot go deeper")
                        return true  -- Consider this success at bedrock
                    end
                end
            end
        else
            -- X and Z axes when Y is correct
            local target_facing = -1
            
            if math.abs(dx) >= math.abs(dz) then
                target_facing = (dx > 0) and 1 or 3
            else
                target_facing = (dz > 0) and 2 or 0
            end
            
            while turtle_pos.facing ~= target_facing do
                turnRight()
            end
            
            if not smartMove("forward", true) then
                -- Try alternate directions if primary is blocked
                for i = 1, 3 do
                    turnRight()
                    if smartMove("forward", true) then
                        break
                    end
                end
            end
        end
        
        -- Progress update every 5 attempts for deep mining
        if attempts % 5 == 0 then
            local distance = math.abs(dx) + math.abs(dy) + math.abs(dz)
            log("Navigation progress: " .. distance .. " blocks remaining (attempt " .. attempts .. ") Y=" .. turtle_pos.y)
        end
    end
    
    log("Navigation completed after " .. attempts .. " attempts (may not be exact)", "WARN")
    return true  -- Return success even if not exact - Ender Modems should make this rare
end

-- ===== UTILITY FUNCTIONS =====
local function getDistanceFromStart()
    return math.abs(turtle_pos.x - start_pos.x) + 
           math.abs(turtle_pos.y - start_pos.y) + 
           math.abs(turtle_pos.z - start_pos.z)
end

-- ===== FUEL MANAGEMENT =====
local function manageFuel()
    local fuelLevel = turtle.getFuelLevel()
    if fuelLevel < CONFIG.minFuel then
        log("Low fuel: " .. fuelLevel)
        
        for i = 1, 16 do
            if not tableContains(CONFIG.protectedSlots, i) then
                turtle.select(i)
                local item = turtle.getItemDetail()
                if item then
                    local fuelValue = turtle.getFuelLevel()
                    turtle.refuel(1)
                    if turtle.getFuelLevel() > fuelValue then
                        log("Refueled with: " .. item.name)
                        return true
                    end
                end
            end
        end
        
        log("No fuel found in inventory", "WARN")
        return false
    end
    return true
end

-- ===== SAFETY CHECKS =====
local function validateSetup()
    local issues = {}
    
    turtle.select(CONFIG.chestSlot)
    if turtle.getItemCount() == 0 then
        table.insert(issues, "No chests in slot " .. CONFIG.chestSlot)
    end
    
    turtle.select(CONFIG.torchSlot)
    if turtle.getItemCount() == 0 then
        table.insert(issues, "No torches in slot " .. CONFIG.torchSlot)
    end
    
    local estimatedMoves = 1000
    if mining_type and mining_length and mining_tunnelWidth and mining_depth then
        if mining_type == "room" then
            estimatedMoves = mining_length * mining_tunnelWidth * mining_depth * 2
        elseif mining_numTunnels then
            estimatedMoves = (mining_length + mining_tunnelWidth) * mining_numTunnels * (mining_depth + 2) * 2
        end
    end
    
    if turtle.getFuelLevel() < estimatedMoves then
        table.insert(issues, "Low fuel: need " .. estimatedMoves .. ", have " .. turtle.getFuelLevel())
    end
    
    if not turtle.forward() then
        if turtle.detect() then
            if not protectedDig("forward") then
                table.insert(issues, "Cannot break blocks - check tool")
            else
                turtle.forward()
                turtle.back()
            end
        else
            table.insert(issues, "Cannot move forward")
        end
    else
        turtle.back()
    end
    
    return issues
end

local function checkEmergency()
    if turtle.getFuelLevel() < 100 then
        log("CRITICAL: Fuel too low", "ERROR")
        return "fuel"
    end
    
    turtle.select(CONFIG.chestSlot)
    if turtle.getItemCount(CONFIG.chestSlot) == 0 and isInventoryFull() then
        log("CRITICAL: No chests and inventory full", "ERROR")
        return "chests"
    end
    
    if getDistanceFromStart() > CONFIG.maxChunkDistance then
        log("WARNING: Too far from start!", "WARN")
        return "distance"
    end
    
    if emergency_stop then
        log("EMERGENCY STOP activated!", "ERROR")
        return "manual"
    end
    
    return false
end

-- ===== INVENTORY MANAGEMENT =====
local function isValuable(itemName)
    if not itemName then return false end
    local name = itemName:lower()
    for _, valuable in ipairs(CONFIG.valuableItems) do
        if name:find(valuable) then return true end
    end
    return false
end

local function isJunk(itemName)
    if not itemName then return false end
    local name = itemName:lower()
    for _, junk in ipairs(CONFIG.junkItems) do
        if name:find(junk) then return true end
    end
    return false
end

-- NEW: Enhanced inventory compression
local function compressInventory()
    log("Compressing inventory...")
    local compressed = 0
    
    -- First pass: identify all items
    local item_stacks = {}
    for i = 1, 16 do
        if not tableContains(CONFIG.protectedSlots, i) then
            turtle.select(i)
            local item = turtle.getItemDetail()
            if item then
                if not item_stacks[item.name] then
                    item_stacks[item.name] = {}
                end
                table.insert(item_stacks[item.name], {
                    slot = i,
                    count = item.count,
                    maxCount = 64  -- Default max stack
                })
            end
        end
    end
    
    -- Second pass: compress stacks
    for item_name, stacks in pairs(item_stacks) do
        if #stacks > 1 then
            -- Sort by count (ascending) to fill smallest stacks first
            table.sort(stacks, function(a, b) return a.count < b.count end)
            
            for i = 1, #stacks - 1 do
                if stacks[i].count < stacks[i].maxCount then
                    turtle.select(stacks[#stacks].slot)
                    if turtle.transferTo(stacks[i].slot) then
                        compressed = compressed + 1
                        
                        -- Update counts
                        local transferred = math.min(
                            stacks[#stacks].count,
                            stacks[i].maxCount - stacks[i].count
                        )
                        stacks[i].count = stacks[i].count + transferred
                        stacks[#stacks].count = stacks[#stacks].count - transferred
                        
                        -- Remove empty stack
                        if stacks[#stacks].count == 0 then
                            table.remove(stacks)
                        end
                    end
                end
            end
        end
    end
    
    stats.inventory_compressions = stats.inventory_compressions + 1
    log("Compressed " .. compressed .. " item stacks")
    return compressed
end

local function sortInventory()
    local valuable = {}
    local junk = {}
    local other = {}
    
    -- Compress inventory first
    compressInventory()
    
    for i = 1, 16 do
        if not tableContains(CONFIG.protectedSlots, i) then
            turtle.select(i)
            local item = turtle.getItemDetail()
            if item then
                if isValuable(item.name) then
                    table.insert(valuable, {slot = i, item = item})
                elseif isJunk(item.name) then
                    table.insert(junk, {slot = i, item = item})
                else
                    table.insert(other, {slot = i, item = item})
                end
            end
        end
    end
    
    stats.valuable_found = #valuable
    return valuable, junk, other
end

local function isInventoryFull()
    local freeSlots = 0
    for i = 1, 16 do
        if not tableContains(CONFIG.protectedSlots, i) and turtle.getItemCount(i) == 0 then
            freeSlots = freeSlots + 1
        end
    end
    return freeSlots <= 2
end

local function depositItems()
    log("Inventory full - placing chest...")
    
    local chest_x, chest_y, chest_z = turtle_pos.x, turtle_pos.y, turtle_pos.z
    local behind_facing = (turtle_pos.facing + 2) % 4
    if behind_facing == 0 then chest_z = chest_z - 1
    elseif behind_facing == 1 then chest_x = chest_x + 1
    elseif behind_facing == 2 then chest_z = chest_z + 1
    elseif behind_facing == 3 then chest_x = chest_x - 1
    end
    
    turnRight()
    turnRight()
    
    turtle.select(CONFIG.chestSlot)
    if turtle.getItemCount(CONFIG.chestSlot) > 0 then
        if turtle.place() then
            stats.chests_placed = stats.chests_placed + 1
            addChestPosition(chest_x, chest_y, chest_z)
            log("Placed chest #" .. stats.chests_placed .. " at " .. chest_x .. "," .. chest_y .. "," .. chest_z)
        else
            log("Failed to place chest", "ERROR")
            turnRight()
            turnRight()
            return false
        end
    else
        log("No chests available", "ERROR")
        turnRight()
        turnRight()
        return false
    end
    
    sleep(0.5)
    
    local valuable, junk, other = sortInventory()
    local totalItems = #valuable + #junk + #other
    
    log("Depositing " .. totalItems .. " items")
    
    for _, item in ipairs(junk) do
        turtle.select(item.slot)
        turtle.drop()
    end
    
    for _, item in ipairs(other) do
        turtle.select(item.slot)
        turtle.drop()
    end
    
    local keepValuable = math.min(#valuable, 3)
    for i = keepValuable + 1, #valuable do
        turtle.select(valuable[i].slot)
        turtle.drop()
    end
    
    stats.items_collected = stats.items_collected + (totalItems - keepValuable)
    log("Deposited " .. (totalItems - keepValuable) .. " items, kept " .. keepValuable .. " valuable")
    
    turnRight()
    turnRight()
    return true
end

-- ===== LIGHTING SYSTEM =====
local function placeTorch(safeMode, allowGround)
    turtle.select(CONFIG.torchSlot)
    if turtle.getItemCount(CONFIG.torchSlot) > 0 then
        turnRight()
        local wall_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z}
        if turtle_pos.facing == 0 then wall_pos.z = wall_pos.z - 1
        elseif turtle_pos.facing == 1 then wall_pos.x = wall_pos.x + 1
        elseif turtle_pos.facing == 2 then wall_pos.z = wall_pos.z + 1
        elseif turtle_pos.facing == 3 then wall_pos.x = wall_pos.x - 1
        end
        
        if turtle.place() then
            addTorchPosition(wall_pos.x, wall_pos.y, wall_pos.z, "right_wall")
            turnLeft()
            log("Placed torch on right wall")
            return true
        end
        
        turnLeft()
        turnLeft()
        wall_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z}
        if turtle_pos.facing == 0 then wall_pos.z = wall_pos.z - 1
        elseif turtle_pos.facing == 1 then wall_pos.x = wall_pos.x + 1
        elseif turtle_pos.facing == 2 then wall_pos.z = wall_pos.z + 1
        elseif turtle_pos.facing == 3 then wall_pos.x = wall_pos.x - 1
        end
        
        if turtle.place() then
            addTorchPosition(wall_pos.x, wall_pos.y, wall_pos.z, "left_wall")
            turnRight()
            log("Placed torch on left wall")
            return true
        end
        
        turnRight()
        
        if allowGround and not safeMode then
            if turtle.placeDown() then
                local ground_pos = {x = turtle_pos.x, y = turtle_pos.y - 1, z = turtle_pos.z}
                addTorchPosition(ground_pos.x, ground_pos.y, ground_pos.z, "ground")
                log("Placed torch on ground")
                return true
            end
        end
        
        if safeMode then
            if turtle.placeUp() then
                local ceiling_pos = {x = turtle_pos.x, y = turtle_pos.y + 1, z = turtle_pos.z}
                addTorchPosition(ceiling_pos.x, ceiling_pos.y, ceiling_pos.z, "ceiling")
                log("Placed torch on ceiling")
                return true
            end
        end
    else
        log("No torches available", "WARN")
    end
    return false
end

-- ===== PROGRESS TRACKING =====
local function calculateProgress()
    if stats.start_time == 0 then
        return {percentage = 0, eta_minutes = 0, blocks_per_second = 0}
    end
    
    local elapsed_time = os.clock() - stats.start_time
    local totalBlocks = 1000
    
    if mining_type and mining_length and mining_tunnelWidth and mining_depth then
        if mining_type == "room" then
            totalBlocks = mining_length * mining_tunnelWidth * mining_depth
        elseif mining_numTunnels then
            totalBlocks = mining_length * mining_tunnelWidth * mining_numTunnels * mining_depth
        end
    end
    
    local blocksPerSecond = safeDiv(stats.blocks_mined, elapsed_time, 0)
    local remainingBlocks = totalBlocks - stats.blocks_mined
    local eta_seconds = safeDiv(remainingBlocks, blocksPerSecond, 0)
    
    return {
        percentage = math.min(safeDiv(stats.blocks_mined, totalBlocks, 0) * 100, 100),
        eta_minutes = eta_seconds / 60,
        blocks_per_second = blocksPerSecond
    }
end

local function displayProgress()
    local progress = calculateProgress()
    log(string.format("Progress: %.1f%% | ETA: %.1f min | Speed: %.2f blocks/sec", 
        progress.percentage, progress.eta_minutes, progress.blocks_per_second))
    
    if stats.chests_avoided > 0 or stats.torches_replaced > 0 or stats.alternative_routes_used > 0 then
        log("Protection stats: " .. stats.chests_avoided .. " chests avoided, " .. 
            stats.torches_replaced .. " torches replaced, " .. 
            stats.alternative_routes_used .. " detours used")
    end
    
    -- Display ore statistics if any found
    if not isEmpty(stats.ore_types_found) then
        local ore_summary = "Ores found: "
        for ore_type, count in pairs(stats.ore_types_found) do
            ore_summary = ore_summary .. ore_type .. "=" .. count .. " "
        end
        log(ore_summary)
    end
    
    -- Display modded ore stats
    if stats.modded_ores_discovered > 0 or stats.custom_ores_found > 0 then
        log("Modded ores: " .. stats.modded_ores_discovered .. " discovered, " .. stats.custom_ores_found .. " custom found")
    end
end

-- NEW: Generate detailed mining report with modded support
local function generateMiningReport()
    local report = {
        "=== MODDED MINECRAFT MINING REPORT ===",
        "Date: " .. os.day() .. " Time: " .. textutils.formatTime(os.time()),
        "Computer ID: " .. os.getComputerID(),
        "Mining Type: " .. (mining_type or "unknown"),
        "",
        "SUMMARY:",
        "- Total blocks mined: " .. stats.blocks_mined,
        "- 3x3 blocks mined: " .. stats.blocks_3x3_mined,
        "- Runtime: " .. string.format("%.1f", safeDiv(stats.runtime, 60, 0)) .. " minutes",
        "- Average speed: " .. string.format("%.2f", safeDiv(stats.blocks_mined, stats.runtime, 0)) .. " blocks/sec",
        "",
        "RESOURCES:",
        "- Chests placed: " .. stats.chests_placed,
        "- Fuel consumed: " .. stats.fuel_consumed,
        "- Fuel efficiency: " .. string.format("%.2f", safeDiv(stats.blocks_mined, stats.fuel_consumed, 0)) .. " blocks/fuel",
        "",
        "NAVIGATION:",
        "- Coordinate updates: " .. stats.coordinate_updates,
        "- Coordinate failures: " .. stats.coordinate_failures,
        "- Alternative routes used: " .. stats.alternative_routes_used,
        "- Emergency returns: " .. stats.emergency_returns,
        "",
        "ENCOUNTERS:",
        "- Liquids encountered: " .. stats.liquids_encountered,
        "- Bedrock hits: " .. stats.bedrock_hits,
        "- Chests avoided: " .. stats.chests_avoided,
        "- Torches replaced: " .. stats.torches_replaced,
        "",
        "INVENTORY:",
        "- Items collected: " .. stats.items_collected,
        "- Inventory compressions: " .. stats.inventory_compressions,
        "- Ore veins followed: " .. stats.ore_veins_followed,
        "",
        "MODDED MINECRAFT STATISTICS:",
        "- Modded ores discovered: " .. stats.modded_ores_discovered,
        "- Custom ores found: " .. stats.custom_ores_found,
        "- Auto-detection enabled: " .. tostring(CONFIG.auto_detect_modded_ores),
        "",
        "ORES FOUND:"
    }
    
    if not isEmpty(stats.ore_types_found) then
        for ore, count in pairs(stats.ore_types_found) do
            table.insert(report, "- " .. ore .. ": " .. count)
        end
    else
        table.insert(report, "- No ores tracked")
    end
    
    -- Add modded-specific information
    table.insert(report, "")
    table.insert(report, "NEW MODDED ORES DISCOVERED:")
    if not isEmpty(discovered_ores) then
        for ore_name, info in pairs(discovered_ores) do
            table.insert(report, "- " .. info.name .. " (" .. ore_name .. ") Priority: " .. info.priority)
        end
    else
        table.insert(report, "- No new modded ores discovered this session")
    end
    
    table.insert(report, "")
    table.insert(report, "CUSTOM ORE CONFIGURATION:")
    if not isEmpty(custom_ore_priorities) then
        table.insert(report, "Custom priorities loaded from " .. CONFIG.modded_ore_file .. ":")
        for ore_name, info in pairs(custom_ore_priorities) do
            table.insert(report, "- " .. info.name .. " (Priority " .. info.priority .. ")")
        end
    else
        table.insert(report, "- Using auto-detection only")
    end
    
    table.insert(report, "")
    table.insert(report, "MODDED MINECRAFT NOTES:")
    table.insert(report, "- To customize ore priorities, edit: " .. CONFIG.modded_ore_file)
    table.insert(report, "- Discovered ores saved to: " .. CONFIG.discovered_ores_file)
    table.insert(report, "- Priorities 7+ enable automatic vein following")
    table.insert(report, "- Support for: Thermal, Mekanism, AE2, Tinkers, IC2, IE, and more!")
    
    table.insert(report, "")
    table.insert(report, "END OF REPORT")
    
    -- Create reports directory if it doesn't exist
    if not fs.exists("mining_reports") then
        fs.makeDir("mining_reports")
    end
    
    -- Save report
    local filename = "mining_reports/report_" .. os.day() .. "_" .. math.floor(os.time()) .. ".txt"
    local success, err = safeFileWrite(filename, table.concat(report, "\n"))
    
    if success then
        log("Mining report saved to: " .. filename)
    else
        log("Failed to save mining report: " .. (err or "unknown error"), "ERROR")
    end
    
    -- Also display report to screen
    print("")
    print("=== FINAL MODDED MINECRAFT REPORT ===")
    for i = 6, math.min(#report, 35) do  -- Show key parts
        print(report[i])
    end
    print("Full report saved to: " .. filename)
    
    return report
end

-- ===== RETURN HOME & EMERGENCY =====
-- NEW: Enhanced emergency return
local function emergencyReturnHome()
    log("EMERGENCY: Initiating emergency return protocol", "ERROR")
    stats.emergency_returns = stats.emergency_returns + 1
    
    -- Save current position for recovery
    saveEmergencyPosition()
    
    -- Try GPS navigation first
    if returnHome() then
        log("Emergency return successful via GPS")
        return true
    end
    
    -- Fallback: Try to reach surface
    log("GPS failed, attempting surface escape", "WARN")
    local surface_attempts = 0
    local start_y = turtle_pos.y
    
    while turtle_pos.y < 64 and surface_attempts < 200 do
        if not safeMove("up") then
            -- Try to dig around obstacles
            local cleared = false
            for i = 1, 4 do
                if protectedDig("forward") then
                    cleared = true
                    break
                end
                turnRight()
            end
            
            if not cleared then
                -- Try to move horizontally then up
                for i = 1, 4 do
                    if safeMove("forward") then
                        break
                    end
                    turnRight()
                end
            end
        end
        
        surface_attempts = surface_attempts + 1
        
        -- Progress update
        if surface_attempts % 20 == 0 then
            log("Surface escape progress: Y=" .. turtle_pos.y .. " (from Y=" .. start_y .. ")")
        end
    end
    
    if turtle_pos.y >= 0 then
        log("Reached surface! Current Y=" .. turtle_pos.y)
        -- Try GPS again from surface
        updatePosition(true)
        return returnHome()
    else
        log("Failed to reach surface after " .. surface_attempts .. " attempts", "ERROR")
        return false
    end
end

local function returnHome()
    log("=== RETURNING HOME ===")
    log("Home coordinates: " .. start_pos.x .. ", " .. start_pos.y .. ", " .. start_pos.z)
    
    if navigateToCoordinate(start_pos.x, start_pos.y, start_pos.z, 200) then
        log("=== ARRIVED HOME ===")
        return true
    else
        log("Could not navigate home automatically", "ERROR")
        return false
    end
end

-- ===== ROOM MINING ALGORITHMS =====
local function mineRoomFloor(length, width, level)
    log("Mining room floor " .. length .. "x" .. width .. " at level " .. level .. " (Y=" .. turtle_pos.y .. ")")
    
    local room_start_x = turtle_pos.x
    local room_start_y = turtle_pos.y
    local room_start_z = turtle_pos.z
    
    log("Room excavation starting from: " .. room_start_x .. "," .. room_start_y .. "," .. room_start_z)
    
    local blocks_excavated = 0
    local going_right = true
    local navigation_failures = 0
    local max_nav_failures = 15  -- Higher threshold with Ender Modems
    
    for row = 0, length - 1 do
        for col = 0, width - 1 do
            
            local target_x, target_z
            if going_right then
                target_x = room_start_x + col
                target_z = room_start_z + row
            else
                target_x = room_start_x + (width - 1 - col)
                target_z = room_start_z + row
            end
            
            -- Ender Modems: Always use GPS navigation (reliable at all depths)
            if not navigateToCoordinate(target_x, room_start_y, target_z) then
                log("GPS navigation failed for position " .. target_x .. "," .. room_start_y .. "," .. target_z)
                navigation_failures = navigation_failures + 1
                
                -- With Ender Modems, navigation failures are more serious
                if navigation_failures > max_nav_failures then
                    log("Too many navigation failures (" .. navigation_failures .. ") - check Ender Modem setup", "ERROR")
                    return false
                end
                
                -- Try simple movement as fallback
                log("Attempting simple movement fallback...")
                local attempts = 0
                while attempts < 10 do
                    attempts = attempts + 1
                    
                    local dx = target_x - turtle_pos.x
                    local dz = target_z - turtle_pos.z
                    
                    if math.abs(dx) <= 1 and math.abs(dz) <= 1 then
                        break  -- Close enough
                    end
                    
                    if math.abs(dx) >= math.abs(dz) then
                        local target_facing = (dx > 0) and 1 or 3
                        while turtle_pos.facing ~= target_facing do
                            turnRight()
                        end
                    else
                        local target_facing = (dz > 0) and 2 or 0
                        while turtle_pos.facing ~= target_facing do
                            turnRight()
                        end
                    end
                    
                    if not smartMove("forward", true) then
                        break  -- Can't move further
                    end
                end
            end
            
            -- Resource and emergency checks
            local emergency = checkEmergency()
            if emergency then
                log("Room mining stopped: " .. emergency, "WARN")
                return false
            end
            
            if not manageFuel() then
                log("Fuel management failed during room mining")
                return false
            end
            
            if isInventoryFull() then
                if not depositItems() then
                    log("Failed to deposit items during room mining")
                    return false
                end
            end
            
            -- Enhanced mining with 3x3 option
            if CONFIG.enable3x3Mining and row % 3 == 1 and col % 3 == 1 then
                mine3x3Forward()
                blocks_excavated = blocks_excavated + 9  -- Approximate
            else
                -- Standard excavation
                if protectedDig("up") then
                    blocks_excavated = blocks_excavated + 1
                end
                
                if protectedDig("forward") then
                    blocks_excavated = blocks_excavated + 1
                end
                
                if protectedDig("down") then
                    blocks_excavated = blocks_excavated + 1
                end
            end
            
            -- Place torch periodically for good lighting
            if (row + col) % (CONFIG.torchSpacing) == 0 and row > 1 and col > 1 and row < length and col < width then
                placeTorch(false, true)
            end
            
            -- Progress update every 25 blocks
            if blocks_excavated % 25 == 0 and blocks_excavated > 0 then
                local room_progress = ((row * width + col + 1) / (length * width)) * 100
                log("Room excavation progress: " .. string.format("%.1f", room_progress) .. "% (" .. blocks_excavated .. " blocks)")
                log("Current position: " .. turtle_pos.x .. "," .. turtle_pos.y .. "," .. turtle_pos.z)
                displayProgress()
            end
        end
        
        -- Switch direction for next row (zig-zag pattern)
        going_right = not going_right
    end
    
    log("Successfully excavated room floor at level " .. level .. " (" .. blocks_excavated .. " blocks)")
    log("Navigation failures: " .. navigation_failures .. "/" .. max_nav_failures .. " (Ender Modem GPS)")
    return true
end

local function navigateToRoomCorner(length, width)
    log("Navigating to northwest corner of room")
    
    local max_boundary_moves = math.max(length, width) + 2
    
    while turtle_pos.facing ~= 0 do
        turnRight()
    end
    
    local moves = 0
    while moves < max_boundary_moves do
        if not smartMove("forward", true) then
            break
        end
        moves = moves + 1
    end
    
    while turtle_pos.facing ~= 3 do
        turnRight()
    end
    
    moves = 0
    while moves < max_boundary_moves do
        if not smartMove("forward", true) then
            break
        end
        moves = moves + 1
    end
    
    while turtle_pos.facing ~= 1 do
        turnRight()
    end
    
    log("Positioned at corner, facing east for perimeter stairs")
    return true
end

local function createDescentToNextLevel()
    log("Creating descent point to next level (current Y=" .. turtle_pos.y .. ")")
    
    -- First, clear the space below
    protectedDig("down")
    
    -- Try to move down
    if smartMove("down", false) then
        log("Successfully descended to next level (Y=" .. turtle_pos.y .. ")")
        
        if turtle_pos.y <= -60 then
            log("WARNING: Approaching bedrock level (Y=" .. turtle_pos.y .. ")")
        end
        
        return true
    else
        -- If we can't move down, investigate why
        local success, data = turtle.inspectDown()
        if success then
            log("Blocked by: " .. (data.name or "unknown block"))
            if data.name and data.name:lower():find("bedrock") then
                log("CONFIRMED: Hit actual bedrock at Y=" .. turtle_pos.y)
                stats.bedrock_hits = stats.bedrock_hits + 1
                return false
            else
                log("Blocked by " .. data.name .. " - trying to break through")
                -- Try harder to dig through
                for i = 1, 5 do
                    if protectedDig("down") then
                        log("Broke through obstacle, trying to descend again")
                        if smartMove("down", false) then
                            log("Successfully descended after clearing obstacle (Y=" .. turtle_pos.y .. ")")
                            return true
                        end
                    end
                    sleep(0.5)
                end
                log("Cannot break through obstacle - may be bedrock or liquid")
                return false
            end
        else
            log("No block detected below but cannot move - may be at world bottom")
            if turtle_pos.y <= -64 then
                log("At bedrock level (Y=" .. turtle_pos.y .. ") - cannot go deeper")
                stats.bedrock_hits = stats.bedrock_hits + 1
                return false
            else
                log("Unknown obstacle preventing descent at Y=" .. turtle_pos.y)
                return false
            end
        end
    end
end

local function createRoomStairs(length, width, level, room_start)
    log("Creating stairs around room perimeter at level " .. level)
    
    if not navigateToRoomCorner(length, width) then
        log("Failed to navigate to room corner for stairs")
        return false
    end
    
    local perimeter_plan = {
        {name = "north_wall", steps = width - 1, turn = "right"},
        {name = "east_wall", steps = length - 1, turn = "right"},
        {name = "south_wall", steps = width - 1, turn = "right"},
        {name = "west_wall", steps = length - 2, turn = "right"}
    }
    
    local total_torches = 0
    
    for _, segment in ipairs(perimeter_plan) do
        log("Creating " .. segment.name .. " stairs (" .. segment.steps .. " steps)")
        
        for step = 1, segment.steps do
            local emergency = checkEmergency()
            if emergency then
                log("Stair creation stopped: " .. emergency, "WARN")
                return false
            end
            
            if not manageFuel() then
                return false
            end
            
            if isInventoryFull() then
                if not depositItems() then
                    return false
                end
            end
            
            protectedDig("up")
            protectedDig("forward")
            protectedDig("down")
            
            if step % CONFIG.torchSpacing == 0 then
                if placeTorch(false, true) then
                    total_torches = total_torches + 1
                    log("Placed staircase torch #" .. total_torches)
                end
            end
            
            if step < segment.steps then
                if not smartMove("forward", true) then
                    log("Blocked creating " .. segment.name .. " at step " .. step)
                    return false
                end
            end
        end
        
        if segment.turn == "right" then
            turnRight()
        end
        
        log("Completed " .. segment.name .. " stairs with lighting")
    end
    
    log("Perimeter stairs complete at level " .. level .. " with " .. total_torches .. " torches")
    
    if not createDescentToNextLevel() then
        log("Failed to create descent to next level")
        return false
    end
    
    return true
end

local function navigateToRoomLevel(room_start, level)
    log("Navigating to room start for level " .. level .. " (target Y=" .. (room_start.y - (level - 1)) .. ")")
    
    local target_y = room_start.y - (level - 1)
    
    -- Ender Modems: Always use GPS-based navigation (works at all depths)
    log("Using Ender Modem GPS navigation for level " .. level)
    
    if not navigateToCoordinate(room_start.x, target_y, room_start.z, 60) then
        log("GPS navigation failed for level " .. level, "ERROR")
        return false
    end
    
    -- Set correct facing direction
    while turtle_pos.facing ~= room_start.facing do
        turnRight()
    end
    
    log("Successfully navigated to level " .. level .. " (Y=" .. turtle_pos.y .. ")")
    return true
end

local function roomMine(length, width, numSections, depth, direction)
    log("=== ENDER MODEM ROOM MINING WITH SPIRAL STAIRCASE ===")
    log("Creating room: " .. length .. "x" .. width .. " with " .. depth .. " levels deep")
    log("Will mine from Y=" .. turtle_pos.y .. " down to Y=" .. (turtle_pos.y - depth + 1))
    log("Using Ender Modem GPS for precise navigation at all depths")
    log("Enhanced features: 3x3 mining=" .. tostring(CONFIG.enable3x3Mining) .. ", Ore tracking=" .. tostring(CONFIG.followOreVeins))
    log("MODDED SUPPORT: Auto-detection enabled, " .. countTableElements(custom_ore_priorities) .. " custom ores configured")
    
    local room_start = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z, facing = turtle_pos.facing}
    
    local total_blocks = length * width * depth
    local blocks_per_level = length * width
    
    log("Estimated total blocks to mine: " .. total_blocks)
    
    for level = 1, depth do
        log("=== MINING LEVEL " .. level .. " of " .. depth .. " ===")
        log("Target Y level: " .. (room_start.y - (level - 1)))
        
        local level_start_blocks = stats.blocks_mined
        
        if level > 1 then
            log("Navigating to level " .. level)
            if not navigateToRoomLevel(room_start, level) then
                log("Failed to navigate to level " .. level)
                log("PARTIAL SUCCESS: Completed " .. (level - 1) .. " of " .. depth .. " levels")
                return level - 1
            end
        end
        
        log("Excavating floor area at level " .. level .. " (" .. blocks_per_level .. " blocks)")
        
        if not mineRoomFloor(length, width, level) then
            log("Failed to excavate room level " .. level)
            log("PARTIAL SUCCESS: Completed " .. (level - 1) .. " of " .. depth .. " levels")
            return level - 1
        end
        
        local level_blocks_mined = stats.blocks_mined - level_start_blocks
        log("Level " .. level .. " excavation complete: " .. level_blocks_mined .. " blocks mined")
        
        log("Floor level " .. level .. " complete (excavated and lit)")
        
        if level < depth then
            log("Creating staircase from level " .. level .. " to level " .. (level + 1))
            if not createRoomStairs(length, width, level, room_start) then
                log("Failed to create stairs at level " .. level)
                
                local current_y = room_start.y - level
                if current_y <= -64 then
                    log("Hit bedrock at level " .. level .. " (Y=" .. current_y .. ") - stopping excavation")
                    log("BEDROCK REACHED: Completed " .. level .. " levels successfully")
                    return level
                end
                
                log("PARTIAL SUCCESS: Completed " .. level .. " levels, stairs failed")
                return level
            end
            log("Staircase from level " .. level .. " complete")
        end
        
        local progress = (level / depth) * 100
        log("PROGRESS: " .. string.format("%.1f", progress) .. "% complete (" .. level .. "/" .. depth .. " levels)")
        log("Current Y position: " .. turtle_pos.y)
        displayProgress()
    end
    
    log("=== ENDER MODEM ROOM MINING COMPLETE! ===")
    log("Successfully created " .. depth .. " level underground room!")
    log("Total dimensions: " .. length .. "x" .. width .. "x" .. depth)
    log("Final Y position: " .. turtle_pos.y)
    log("Depth achieved: " .. (room_start.y - turtle_pos.y) .. " blocks deep")
    log("Total blocks mined: " .. stats.blocks_mined)
    log("Chests placed: " .. stats.chests_placed)
    log("Chests avoided: " .. (stats.chests_avoided or 0))
    log("Torches replaced: " .. (stats.torches_replaced or 0))
    log("MODDED ORES: " .. stats.modded_ores_discovered .. " discovered, " .. stats.custom_ores_found .. " custom found")
    
    -- Generate mining report
    generateMiningReport()
    
    return depth
end

-- ===== STRIP MINING ALGORITHMS =====
local function mineAtPosition(width, depth)
    local actual_depth = 0
    
    for d = 1, depth do
        -- Enhanced mining with ore detection
        analyzeOre("up")
        analyzeOre("forward")
        analyzeOre("down")
        
        if CONFIG.enable3x3Mining and d % 3 == 1 then
            mine3x3Forward()
        else
            protectedDig("up")
            protectedDig("forward")
            protectedDig("down")
        end
        
        if d % CONFIG.torchSpacing == 0 then
            placeTorch(false, true)
        end
        
        if d < depth then
            if not smartMove("down", false) then
                local success, data = turtle.inspectDown()
                if success and data.name and data.name:lower():find("bedrock") then
                    log("Hit bedrock at depth " .. d .. " (Y=" .. turtle_pos.y .. ")")
                    stats.bedrock_hits = stats.bedrock_hits + 1
                    actual_depth = d - 1
                    break
                else
                    log("Hit obstacle at depth " .. d .. "/" .. depth)
                    actual_depth = d - 1
                    break
                end
            else
                actual_depth = d
                
                if turtle_pos.y <= -60 then
                    log("WARNING: Approaching bedrock (Y=" .. turtle_pos.y .. ")")
                end
            end
        else
            actual_depth = d
        end
    end
    
    for d = 1, actual_depth do
        if not smartMove("up", false) then
            log("Cannot return to start level")
            break
        end
    end
    
    return true
end

local function mineTunnel(length, width, depth)
    local distance = 0
    
    while distance < length do
        local emergency = checkEmergency()
        if emergency then
            log("Tunnel mining stopped: " .. emergency, "WARN")
            if emergency == "fuel" or emergency == "chests" then
                -- Try emergency return
                if emergencyReturnHome() then
                    log("Emergency return successful")
                    return "emergency_return"
                end
            end
            return emergency
        end
        
        if not manageFuel() then
            return "fuel"
        end
        
        if isInventoryFull() then
            if not depositItems() then
                log("Failed to deposit items", "ERROR")
                return "inventory"
            end
        end
        
        if distance % CONFIG.torchSpacing == 0 and distance > 0 then
            placeTorch(false, true)
        end
        
        if not mineAtPosition(width, depth) then
            log("Failed to mine at position")
            return "blocked"
        end
        
        if distance < length - 1 then
            if CONFIG.enable3x3Mining then
                if not mine3x3Forward() then
                    if not smartMove("forward", true) then
                        log("Blocked forward, ending tunnel")
                        return "blocked"
                    end
                end
            else
                if not smartMove("forward", true) then
                    log("Blocked forward, ending tunnel")
                    return "blocked"
                end
            end
        end
        
        distance = distance + 1
        
        if distance % 10 == 0 then
            log("Tunnel progress: " .. distance .. "/" .. length)
            displayProgress()
        end
    end
    
    placeTorch(false, true)
    log("Tunnel complete: " .. length .. " blocks")
    return "success"
end

local function returnToTunnelStart(tunnel_start_pos)
    log("Returning to tunnel start")
    
    if navigateToCoordinate(tunnel_start_pos.x, tunnel_start_pos.y, tunnel_start_pos.z, 150) then
        while turtle_pos.facing ~= tunnel_start_pos.facing do
            turnRight()
        end
        log("Returned to tunnel start")
        return true
    else
        log("Failed to return to tunnel start", "ERROR")
        return false
    end
end

local function stripMine(length, tunnelWidth, spacing, numTunnels, depth, direction)
    log("=== ENDER MODEM STRIP MINING ENHANCED ===")
    log("Mining " .. numTunnels .. " tunnels, " .. length .. " blocks each")
    log("Using Ender Modem GPS for enhanced precision (fallback available)")
    log("Enhanced features: 3x3 mining=" .. tostring(CONFIG.enable3x3Mining) .. ", Ore tracking=" .. tostring(CONFIG.followOreVeins))
    log("MODDED SUPPORT: Auto-detection enabled, " .. countTableElements(custom_ore_priorities) .. " custom ores configured")
    
    local tunnels_completed = 0
    
    for tunnel = 1, numTunnels do
        log("=== TUNNEL " .. tunnel .. "/" .. numTunnels .. " ===")
        
        local tunnel_start_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z, facing = turtle_pos.facing}
        
        local result = mineTunnel(length, tunnelWidth, depth)
        
        if result == "success" then
            tunnels_completed = tunnels_completed + 1
            log("Tunnel " .. tunnel .. " completed successfully")
        elseif result == "emergency_return" then
            log("Emergency return completed - resuming from home")
            -- Try to return to mining
            if navigateToCoordinate(tunnel_start_pos.x, tunnel_start_pos.y, tunnel_start_pos.z, 200) then
                result = mineTunnel(length, tunnelWidth, depth)
                if result == "success" then
                    tunnels_completed = tunnels_completed + 1
                end
            end
        else
            log("Tunnel " .. tunnel .. " stopped: " .. result)
            
            if result == "fuel" or result == "chests" then
                log("Critical shortage - returning home")
                if emergencyReturnHome() then
                    log("Returned home for supplies")
                end
                break
            end
        end
        
        if tunnel < numTunnels then
            if not returnToTunnelStart(tunnel_start_pos) then
                log("Cannot return to tunnel start")
                break
            end
            
            local next_x = tunnel_start_pos.x
            local next_z = tunnel_start_pos.z
            
            if direction == "right" then
                if tunnel_start_pos.facing == 0 then next_x = next_x + (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 1 then next_z = next_z + (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 2 then next_x = next_x - (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 3 then next_z = next_z - (spacing + tunnelWidth)
                end
            else
                if tunnel_start_pos.facing == 0 then next_x = next_x - (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 1 then next_z = next_z - (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 2 then next_x = next_x + (spacing + tunnelWidth)
                elseif tunnel_start_pos.facing == 3 then next_z = next_z + (spacing + tunnelWidth)
                end
            end
            
            log("Moving to next tunnel position: " .. next_x .. ", " .. tunnel_start_pos.y .. ", " .. next_z)
            
            -- Try Ender Modem GPS first, fall back to simple movement if needed
            if not navigateToCoordinate(next_x, tunnel_start_pos.y, next_z, 50) then
                log("GPS navigation failed - using simple movement fallback")
                
                -- Simple movement fallback for strip mining
                local attempts = 0
                while attempts < 30 do
                    attempts = attempts + 1
                    
                    local dx = next_x - turtle_pos.x
                    local dz = next_z - turtle_pos.z
                    
                    if math.abs(dx) <= 2 and math.abs(dz) <= 2 then
                        log("Reached next tunnel position via fallback navigation")
                        break
                    end
                    
                    if math.abs(dx) >= math.abs(dz) then
                        local target_facing = (dx > 0) and 1 or 3
                        while turtle_pos.facing ~= target_facing do
                            turnRight()
                        end
                    else
                        local target_facing = (dz > 0) and 2 or 0
                        while turtle_pos.facing ~= target_facing do
                            turnRight()
                        end
                    end
                    
                    if not smartMove("forward", true) then
                        log("Blocked during fallback navigation - trying alternative route")
                        turnRight()
                        if not smartMove("forward", true) then
                            turnLeft()
                            turnLeft()
                            if not smartMove("forward", true) then
                                turnRight()  -- Back to original facing
                                break
                            end
                        end
                    end
                end
            end
            
            while turtle_pos.facing ~= tunnel_start_pos.facing do
                turnRight()
            end
        end
    end
    
    log("Strip mining complete! " .. tunnels_completed .. "/" .. numTunnels .. " tunnels mined")
    log("Chests avoided: " .. (stats.chests_avoided or 0))
    log("Torches replaced: " .. (stats.torches_replaced or 0))
    log("Alternative routes used: " .. (stats.alternative_routes_used or 0))
    log("MODDED ORES: " .. stats.modded_ores_discovered .. " discovered, " .. stats.custom_ores_found .. " custom found")
    
    -- Generate mining report
    generateMiningReport()
    
    return tunnels_completed
end

-- ===== CONFIGURATION SYSTEM =====
local function getValidatedNumber(prompt, min_val, max_val, default_val)
    repeat
        if default_val then
            write(prompt .. " (" .. min_val .. "-" .. max_val .. ") [default: " .. default_val .. "]: ")
        else
            write(prompt .. " (" .. min_val .. "-" .. max_val .. "): ")
        end
        
        local input = read()
        
        if input == "" and default_val then
            print("Using default: " .. default_val)
            return default_val
        end
        
        local number = tonumber(input)
        if not number then
            print("ERROR: Please enter a valid number!")
        elseif number < min_val or number > max_val then
            print("ERROR: Number must be between " .. min_val .. " and " .. max_val .. "!")
        else
            return number
        end
        print("")
    until false
end

local function getValidatedDirection()
    repeat
        print("Expansion direction:")
        print("  L = Left expansion")
        print("  R = Right expansion")
        write("Enter choice (l/r): ")
        
        local input = read():lower()
        
        if input == "l" or input == "left" then
            print("Selected: Left expansion")
            return "left"
        elseif input == "r" or input == "right" then
            print("Selected: Right expansion")
            return "right"
        else
            print("ERROR: Please enter 'l' for left or 'r' for right!")
            print("")
        end
    until false
end

local function getValidatedYesNo(prompt)
    repeat
        write(prompt .. " (y/n): ")
        local input = read():lower()
        
        if input == "y" or input == "yes" then
            return true
        elseif input == "n" or input == "no" then
            return false
        else
            print("ERROR: Please enter 'y' for yes or 'n' for no!")
        end
    until false
end

local function getValidatedChoice(prompt, choices)
    repeat
        print(prompt)
        for _, choice in ipairs(choices) do
            print("  " .. choice.key .. " = " .. choice.description)
        end
        write("Enter choice: ")
        
        local input = read():lower()
        
        for _, choice in ipairs(choices) do
            if input == choice.key:lower() then
                print("Selected: " .. choice.description)
                return choice.value
            end
        end
        
        local valid_keys = {}
        for _, choice in ipairs(choices) do
            table.insert(valid_keys, choice.key:lower())
        end
        print("ERROR: Invalid choice! Valid options are: " .. table.concat(valid_keys, ", "))
        print("")
    until false
end

local function getMiningConfiguration()
    print("=== MODDED MINECRAFT MINING CONFIGURATION ===")
    print("")
    
    print("MINING MODE SELECTION:")
    local miningMode = getValidatedChoice(
        "Choose your mining strategy:",
        {
            {key = "room", description = "Room mining (excavate large room with spiral stairs)", value = "room"},
            {key = "strip", description = "Strip mining (parallel tunnels)", value = "strip"}
        }
    )
    print("")
    
    -- Ask about enhanced features
    print("=== ENHANCED FEATURES ===")
    CONFIG.enable3x3Mining = getValidatedYesNo("Enable 3x3 mining for efficiency?")
    CONFIG.followOreVeins = getValidatedYesNo("Enable automatic ore vein following?")
    print("")
    
    -- Ask about modded features
    print("=== MODDED MINECRAFT FEATURES ===")
    print("Auto-detection: " .. tostring(CONFIG.auto_detect_modded_ores))
    print("Custom ore file: " .. CONFIG.modded_ore_file)
    print("Current custom ores: " .. countTableElements(custom_ore_priorities))
    if CONFIG.auto_detect_modded_ores then
        print("✓ Will automatically detect and prioritize modded ores")
        print("✓ Priorities 7+ enable automatic vein following")
        print("✓ Edit '" .. CONFIG.modded_ore_file .. "' to customize priorities")
    end
    print("")
    
    if miningMode == "room" then
        print("=== ROOM MINING CONFIGURATION ===")
        mining_length = getValidatedNumber("Room length", 10, 100, 20)
        print("")
        mining_tunnelWidth = getValidatedNumber("Room width", 10, 100, 15)
        print("")
        
        print("DEPTH CONFIGURATION:")
        print("Current Y position: " .. turtle_pos.y)
        print("Bedrock level: Y=-64")
        print("Max possible levels to bedrock: " .. (turtle_pos.y + 64))
        print("")
        print("Quick depth options:")
        print("• To diamond level (Y=15): " .. math.max(1, turtle_pos.y - 15 + 1) .. " levels")
        print("• To bedrock (Y=-64): " .. (turtle_pos.y + 64) .. " levels")
        print("• Current suggestion: Stay shallow for safety")
        print("")
        mining_depth = getValidatedNumber("Number of levels downward", 1, 400, 3)
        print("")
        
        local final_y = turtle_pos.y - (mining_depth - 1)
        print("Mining will go from Y=" .. turtle_pos.y .. " down to Y=" .. final_y)
        if final_y <= -64 then
            print("WARNING: This will reach bedrock! Final depth: " .. math.abs(final_y + 64) .. " levels into bedrock")
        elseif final_y <= 15 then
            print("EXCELLENT: This will reach diamond levels (Y=15 and below)!")
        elseif final_y <= 50 then
            print("GOOD: This will reach good ore levels (iron, gold, redstone)")
        else
            print("INFO: This will stay in upper levels (coal, iron territory)")
        end
        print("")
        
        mining_spacing = 0
        mining_numTunnels = 1
        mining_direction = "right"
        mining_type = "room"
        
        print("Room mining configured: " .. mining_length .. "x" .. mining_tunnelWidth .. " room, " .. mining_depth .. " levels deep")
        print("Final depth: Y=" .. final_y)
        print("Enhanced features: 3x3=" .. tostring(CONFIG.enable3x3Mining) .. ", OreVeins=" .. tostring(CONFIG.followOreVeins))
        print("Modded support: Auto-detect=" .. tostring(CONFIG.auto_detect_modded_ores) .. ", Custom ores=" .. countTableElements(custom_ore_priorities))
        
        if mining_depth > 50 then
            print("")
            print("=== DEEP MINING WARNING ===")
            print("Deep mining (" .. mining_depth .. " levels):")
            print("• Est. time: " .. string.format("%.1f", (mining_length * mining_tunnelWidth * mining_depth) / 100) .. " hours+")
            print("• Chests needed: ~" .. math.ceil(mining_depth / 10) .. "+ stacks")
            print("• Torches needed: ~" .. math.ceil((mining_length * mining_tunnelWidth * mining_depth) / CONFIG.torchSpacing) .. "+")
            print("• This is a MASSIVE operation!")
            print("")
            sleep(1)
        end
        
    else
        print("=== STRIP MINING CONFIGURATION ===")
        mining_length = getValidatedNumber("Tunnel length forward", 10, 500, 50)
        print("")
        mining_tunnelWidth = getValidatedNumber("Tunnel width", 1, 5, 1)
        print("")
        
        print("SPACING BETWEEN TUNNELS:")
        mining_spacing = getValidatedChoice(
            "Choose tunnel spacing:",
            {
                {key = "1", description = "Tight spacing (1 block between tunnels)", value = 1},
                {key = "2", description = "Normal spacing (2 blocks between tunnels)", value = 2},
                {key = "3", description = "Wide spacing (3 blocks between tunnels)", value = 3},
                {key = "custom", description = "Custom spacing (4-10 blocks)", value = -1}
            }
        )
        
        if mining_spacing == -1 then
            mining_spacing = getValidatedNumber("Custom spacing between tunnels", 4, 10, 5)
        end
        print("")
        
        mining_numTunnels = getValidatedNumber("Total number of parallel tunnels", 1, 50, 5)
        print("")
        
        mining_direction = getValidatedDirection()
        print("")
        
        print("DEPTH CONFIGURATION:")
        print("Current Y position: " .. turtle_pos.y)
        print("Bedrock level: Y=-64")
        print("Max possible levels to bedrock: " .. (turtle_pos.y + 64))
        print("")
        print("Quick depth options:")
        print("• To diamond level (Y=15): " .. math.max(1, turtle_pos.y - 15 + 1) .. " levels")
        print("• To bedrock (Y=-64): " .. (turtle_pos.y + 64) .. " levels")
        print("• Current suggestion: Stay shallow for safety")
        print("")
        mining_depth = getValidatedNumber("Mining depth downward", 1, 400, 3)
        print("")
        
        local final_y = turtle_pos.y - (mining_depth - 1)
        print("Mining will go from Y=" .. turtle_pos.y .. " down to Y=" .. final_y)
        if final_y <= -64 then
            print("WARNING: This will reach bedrock! Final depth: " .. math.abs(final_y + 64) .. " levels into bedrock")
        elseif final_y <= 15 then
            print("EXCELLENT: This will reach diamond levels (Y=15 and below)!")
        elseif final_y <= 50 then
            print("GOOD: This will reach good ore levels (iron, gold, redstone)")
        else
            print("INFO: This will stay in upper levels (coal, iron territory)")
        end
        print("")
        
        mining_type = "parallel"
        
        print("Strip mining configured: " .. mining_numTunnels .. " tunnels, " .. mining_length .. " blocks long, " .. mining_spacing .. " spacing")
        print("Final depth: Y=" .. final_y)
        print("Enhanced features: 3x3=" .. tostring(CONFIG.enable3x3Mining) .. ", OreVeins=" .. tostring(CONFIG.followOreVeins))
        print("Modded support: Auto-detect=" .. tostring(CONFIG.auto_detect_modded_ores) .. ", Custom ores=" .. countTableElements(custom_ore_priorities))
        
        if mining_depth > 50 then
            print("")
            print("=== DEEP MINING WARNING ===")
            print("Deep mining (" .. mining_depth .. " levels):")
            local total_blocks = mining_length * mining_tunnelWidth * mining_numTunnels * mining_depth
            print("• Est. time: " .. string.format("%.1f", total_blocks / 100) .. " hours+")
            print("• This is a MASSIVE operation!")
            print("")
            sleep(1)
        end
    end
    
    return true
end

-- ===== MAIN PROGRAM =====
local function main()
    print("=== MINING TURTLE v4.0 ENHANCED MODDED EDITION ===")
    print("Enhanced Ender Modem GPS mining with advanced features")
    print("NEW: Memory optimization, 3x3 mining, ore detection")
    print("NEW: Emergency recovery, inventory compression, reporting")
    print("MODDED: Full modded Minecraft support with auto-detection")
    print("BUGFIXED: All critical issues resolved")
    print("")
    
    -- Initialize modded support first
    if not initializeModdedSupport() then
        log("Failed to initialize modded support", "ERROR")
    end
    
    -- Check for emergency position recovery
    if fs.exists("emergency_position.json") then
        print("=== EMERGENCY RECOVERY DETECTED ===")
        local content = safeFileRead("emergency_position.json")
        if content then
            local emergency_data = textutils.unserialiseJSON(content)
            if emergency_data then
                print("Last emergency position: " .. emergency_data.x .. ", " .. emergency_data.y .. ", " .. emergency_data.z)
                print("Fuel level at emergency: " .. emergency_data.fuel_level)
                print("")
                
                if getValidatedYesNo("Delete emergency recovery file?") then
                    fs.delete("emergency_position.json")
                    print("Emergency file deleted")
                end
                print("")
            end
        end
    end
    
    local hasSavedState = loadState()
    local continueMining = false
    local hasValidConfig = (mining_length and mining_tunnelWidth and mining_numTunnels and 
                           mining_depth and mining_direction and mining_type and 
                           (mining_spacing ~= nil))
    
    if hasSavedState then
        print("=== RESUME MINING DETECTED ===")
        print("Saved position: " .. (turtle_pos.x or 0) .. ", " .. (turtle_pos.y or 0) .. ", " .. (turtle_pos.z or 0))
        
        if hasValidConfig then
            print("Previous configuration found:")
            if mining_type == "room" then
                print("- Room mining: " .. (mining_length or 0) .. "x" .. (mining_tunnelWidth or 0) .. " room")
                print("- " .. (mining_depth or 0) .. " levels deep")
            else
                print("- Strip mining: " .. (mining_numTunnels or 0) .. " tunnels, " .. (mining_length or 0) .. " blocks long")
                print("- " .. (mining_spacing or 0) .. " spacing, " .. (mining_depth or 0) .. " depth")
                print("- Direction: " .. (mining_direction or "unknown"))
            end
            print("- 3x3 mining: " .. tostring(CONFIG.enable3x3Mining))
            print("- Ore vein following: " .. tostring(CONFIG.followOreVeins))
            print("- Modded ore auto-detection: " .. tostring(CONFIG.auto_detect_modded_ores))
            print("- Custom ores configured: " .. countTableElements(custom_ore_priorities))
            if stats.chests_avoided and stats.chests_avoided > 0 then
                print("- Chests avoided: " .. stats.chests_avoided)
                print("- Torches replaced: " .. (stats.torches_replaced or 0))
                print("- Alternative routes used: " .. (stats.alternative_routes_used or 0))
            end
            if stats.ore_types_found and not isEmpty(stats.ore_types_found) then
                print("- Ores found so far:")
                for ore_type, count in pairs(stats.ore_types_found) do
                    print("  • " .. ore_type .. ": " .. count)
                end
            end
            if stats.modded_ores_discovered and stats.modded_ores_discovered > 0 then
                print("- Modded ores discovered: " .. stats.modded_ores_discovered)
                print("- Custom ores found: " .. (stats.custom_ores_found or 0))
            end
        end
        
        print("")
        print("Options:")
        print("  C = Continue from saved position" .. (hasValidConfig and " (with saved config)" or ""))
        print("  N = New mining operation")
        print("  R = View last mining report")
        print("  O = View modded ore configuration")
        print("  Q = Quit")
        write("Choice (c/n/r/o/q): ")
        
        local choice = read():lower()
        if choice == "q" or choice == "quit" then
            return
        elseif choice == "r" or choice == "report" then
            -- Show last report
            if fs.exists("mining_reports") then
                local report_files = fs.list("mining_reports")
                if #report_files > 0 then
                    table.sort(report_files)
                    local last_report = report_files[#report_files]
                    local content = safeFileRead("mining_reports/" .. last_report)
                    if content then
                        print("")
                        print(content)
                        print("")
                        print("Press any key to continue...")
                        os.pullEvent("key")
                    else
                        print("Failed to read report file")
                    end
                else
                    print("No reports found")
                end
            else
                print("No reports directory found")
            end
            return main()  -- Restart main menu
        elseif choice == "o" or choice == "ores" then
            -- Show ore configuration
            print("")
            print("=== MODDED ORE CONFIGURATION ===")
            print("Auto-detection: " .. tostring(CONFIG.auto_detect_modded_ores))
            print("Custom ore file: " .. CONFIG.modded_ore_file)
            print("Discovered ores file: " .. CONFIG.discovered_ores_file)
            print("")
            print("Custom ore priorities (" .. countTableElements(custom_ore_priorities) .. " loaded):")
            if not isEmpty(custom_ore_priorities) then
                for ore_name, info in pairs(custom_ore_priorities) do
                    print("- " .. info.name .. " (Priority " .. info.priority .. ")")
                end
            else
                print("- No custom priorities loaded")
                print("- Edit '" .. CONFIG.modded_ore_file .. "' to add custom priorities")
            end
            print("")
            print("Discovered ores (" .. countTableElements(discovered_ores) .. " total):")
            if not isEmpty(discovered_ores) then
                for ore_name, info in pairs(discovered_ores) do
                    print("- " .. info.name .. " (Priority " .. info.priority .. ")")
                end
            else
                print("- No ores discovered yet")
            end
            print("")
            print("Press any key to continue...")
            os.pullEvent("key")
            return main()  -- Restart main menu
        elseif choice == "c" or choice == "continue" then
            if hasValidConfig then
                continueMining = true
                log("Continuing with mining_type: " .. (mining_type or "unknown"))
            else
                print("No valid configuration found, need to configure")
                continueMining = false
            end
        else
            continueMining = false
        end
    end
    
    if not continueMining then
        if not getMiningConfiguration() then
            log("Configuration cancelled")
            return
        end
        log("New operation configured with mining_type: " .. (mining_type or "unknown"))
    end
    
    log("Initializing coordinates for mining_type: " .. (mining_type or "unknown"))
    if not initializeCoordinates() then
        print("Coordinate initialization failed!")
        if mining_type == "room" then
            print("Room mining requires GPS - cannot continue without coordinates!")
            return
        else
            if not getValidatedYesNo("Strip mining: Continue with limited coordinate functionality?") then
                return
            end
        end
    end
    
    if not continueMining then
        start_pos = {x = turtle_pos.x, y = turtle_pos.y, z = turtle_pos.z}
        log("Set start position: " .. start_pos.x .. ", " .. start_pos.y .. ", " .. start_pos.z)
    else
        log("Using existing start position: " .. start_pos.x .. ", " .. start_pos.y .. ", " .. start_pos.z)
        if mining_type == "room" then
            log("Verifying GPS for resumed room mining...")
            local success, method = updatePosition(true)
            if not success then
                log("GPS verification failed for resumed room mining!", "ERROR")
                print("GPS is required for room mining. Fix GPS and try again.")
                return
            else
                log("GPS verified for room mining continuation: " .. method)
            end
        end
    end
    
    print("")
    print("=== PRE-FLIGHT CHECKS ===")
    local issues = validateSetup()
    if #issues > 0 then
        print("SETUP ISSUES:")
        for _, issue in ipairs(issues) do
            print("• " .. issue)
        end
        print("")
        sleep(0.5)
        if not getValidatedYesNo("Continue anyway?") then
            log("Mining cancelled - setup issues")
            return
        end
    else
        print("All checks passed!")
    end
    
    -- Rotate logs if needed
    rotateLogFile()
    
    saveState()
    
    if not continueMining then
        if not getValidatedYesNo("Start modded Minecraft mining operation?") then
            log("Mining operation cancelled")
            return
        end
    end
    
    if mining_type == "room" then
        print("")
        print("=== ENHANCED MODDED ROOM MINING INFO ===")
        print("Room mining with unlimited range GPS:")
        print("• Ender Modem: Unlimited range in same dimension")
        print("• GPS works at ALL depths (Y=300 to Y=-64)")
        print("• Enhanced features enabled:")
        if CONFIG.enable3x3Mining then
            print("  - 3x3 mining for faster excavation")
        end
        if CONFIG.followOreVeins then
            print("  - Automatic ore vein following")
        end
        print("• Modded Minecraft support:")
        print("  - Auto-detection: " .. tostring(CONFIG.auto_detect_modded_ores))
        print("  - Custom ores: " .. countTableElements(custom_ore_priorities))
        print("  - Supports: Thermal, Mekanism, AE2, Tinkers, IC2, IE, etc.")
        print("• Memory optimization active")
        print("• Detailed mining reports")
        print("• Emergency recovery system")
        print("")
        sleep(0.5)
        if not getValidatedYesNo("Ready to begin enhanced modded room mining?") then
            log("Room mining cancelled")
            return
        end
    else
        print("")
        print("=== ENHANCED MODDED STRIP MINING INFO ===")
        print("Strip mining with enhanced GPS navigation:")
        print("• Ender Modem: Unlimited range for precise tunnels")
        print("• Enhanced features enabled:")
        if CONFIG.enable3x3Mining then
            print("  - 3x3 mining for wider tunnels")
        end
        if CONFIG.followOreVeins then
            print("  - Automatic ore vein following")
        end
        print("• Modded Minecraft support:")
        print("  - Auto-detection: " .. tostring(CONFIG.auto_detect_modded_ores))
        print("  - Custom ores: " .. countTableElements(custom_ore_priorities))
        print("  - Supports: Thermal, Mekanism, AE2, Tinkers, IC2, IE, etc.")
        print("• Inventory compression system")
        print("• Emergency return protocol")
        print("• Detailed mining reports")
        print("")
        sleep(0.5)
        if not getValidatedYesNo("Start enhanced modded strip mining?") then
            log("Strip mining cancelled")
            return
        end
    end
    
    log("=== STARTING ENHANCED MODDED DEEP MINING ===")
    log("Mining type: " .. mining_type)
    log("Protection features: Smart routing around chests (torches replaced)")
    log("Enhanced features: 3x3=" .. tostring(CONFIG.enable3x3Mining) .. ", OreVeins=" .. tostring(CONFIG.followOreVeins))
    log("Modded support: Auto-detect=" .. tostring(CONFIG.auto_detect_modded_ores) .. ", Custom=" .. countTableElements(custom_ore_priorities))
    log("Ender Modem GPS: Unlimited range precision mining to bedrock")
    stats.start_time = os.clock()
    stats.fuel_consumed = turtle.getFuelLevel()
    
    -- Set up emergency stop handler
    parallel.waitForAny(
        function()
            while true do
                local event, key = os.pullEvent("key")
                if key == keys[CONFIG.emergencyKey] then
                    emergency_stop = true
                    log("EMERGENCY STOP KEY PRESSED!", "ERROR")
                    break
                end
            end
        end,
        function()
            local success
            if mining_type == "room" then
                success = roomMine(mining_length, mining_tunnelWidth, 1, mining_depth, mining_direction)
            else
                success = stripMine(mining_length, mining_tunnelWidth, mining_spacing, mining_numTunnels, mining_depth, mining_direction)
            end
            
            stats.runtime = os.clock() - stats.start_time
            stats.fuel_consumed = stats.fuel_consumed - turtle.getFuelLevel()
            
            log("=== MODDED MINECRAFT MINING OPERATION COMPLETE ===")
            if mining_type == "room" then
                if success > 0 then
                    log("Room mining completed successfully with spiral staircase!")
                    log("Levels completed: " .. success .. "/" .. mining_depth)
                    log("Depth reached: Y=" .. turtle_pos.y .. " (started at Y=" .. start_pos.y .. ")")
                    
                    if success < mining_depth then
                        log("PARTIAL COMPLETION REASONS:")
                        log("• Check logs above for specific failure reason")
                        log("• Common causes: GPS failure, bedrock hit, resource shortage, navigation blocked")
                    end
                else
                    log("Room mining failed or was interrupted - check logs for reason")
                end
            else
                log("Tunnels completed: " .. success .. "/" .. mining_numTunnels)
            end
            log("Total time: " .. string.format("%.1f", stats.runtime) .. "s (" .. string.format("%.1f", stats.runtime/60) .. " min)")
            log("Blocks mined: " .. stats.blocks_mined .. " (3x3: " .. stats.blocks_3x3_mined .. ")")
            log("Chests placed: " .. stats.chests_placed)
            log("Fuel consumed: " .. stats.fuel_consumed)
            log("Coordinate updates: " .. stats.coordinate_updates .. " (cached calls not counted)")
            log("Coordinate failures: " .. stats.coordinate_failures)
            log("PROTECTION STATS:")
            log("• Chests avoided: " .. (stats.chests_avoided or 0))
            log("• Torches replaced: " .. (stats.torches_replaced or 0))
            log("• Alternative routes used: " .. (stats.alternative_routes_used or 0))
            log("ENHANCED STATS:")
            log("• Ore veins followed: " .. (stats.ore_veins_followed or 0))
            log("• Liquids encountered: " .. (stats.liquids_encountered or 0))
            log("• Bedrock hits: " .. (stats.bedrock_hits or 0))
            log("• Emergency returns: " .. (stats.emergency_returns or 0))
            log("• Inventory compressions: " .. (stats.inventory_compressions or 0))
            log("MODDED MINECRAFT STATS:")
            log("• Modded ores discovered: " .. (stats.modded_ores_discovered or 0))
            log("• Custom ores found: " .. (stats.custom_ores_found or 0))
            log("• Auto-detection enabled: " .. tostring(CONFIG.auto_detect_modded_ores))
            
            local critical = checkEmergency()
            if critical then
                log("FINAL STATUS: Stopped due to " .. critical .. " shortage", "ERROR")
                log("Returning home...")
                if emergencyReturnHome() then
                    log("Successfully returned home")
                else
                    log("Failed to return home - manual recovery needed", "ERROR")
                end
            else
                log("FINAL STATUS: All operations completed successfully!", "INFO")
                if getValidatedYesNo("Return to home position?") then
                    returnHome()
                end
            end
            
            log("Advanced Mining Turtle v4.0 Modded Edition ready for new instructions!")
            log("Enhanced deep mining with modded ore detection and emergency recovery complete!")
            log("Check '" .. CONFIG.discovered_ores_file .. "' for newly discovered ores!")
        end
    )
end

-- Start the program
main()
